Description: Downgrade packaged rubygems to 2.1.11 to work around https://github.com/bundler/bundler/issues/2847
Author:      Alex Tomlins <alex.tomlins@digital.cabinet-office.gov.uk>
Last-Update: 2014-02-27
diff --git a/lib/rubygems.rb b/lib/rubygems.rb
index 456273e..cbfe634 100644
--- a/lib/rubygems.rb
+++ b/lib/rubygems.rb
@@ -8,7 +8,7 @@
 require 'rbconfig'
 
 module Gem
-  VERSION = '2.2.2'
+  VERSION = '2.1.11'
 end
 
 # Must be first since it unloads the prelude from 1.9.2
@@ -139,7 +139,6 @@ module Gem
     build_info
     cache
     doc
-    extensions
     gems
     specifications
   ]
@@ -159,7 +158,6 @@ module Gem
   @path_to_default_spec_map = {}
   @platforms = []
   @ruby = nil
-  @ruby_api_version = nil
   @sources = nil
 
   @post_build_hooks     ||= []
@@ -178,8 +176,8 @@ module Gem
   def self.try_activate path
     # finds the _latest_ version... regardless of loaded specs and their deps
     # if another gem had a requirement that would mean we shouldn't
-    # activate the latest version, then either it would already be activated
-    # or if it was ambiguous (and thus unresolved) the code in our custom
+    # activate the latest version, then either it would alreaby be activated
+    # or if it was ambigious (and thus unresolved) the code in our custom
     # require will try to activate the more specific version.
 
     spec = Gem::Specification.find_inactive_by_path path
@@ -215,6 +213,50 @@ module Gem
     end
   end
 
+  def self.detect_gemdeps
+    if path = ENV['RUBYGEMS_GEMDEPS']
+      path = path.dup.untaint
+
+      if path == "-"
+        here = Dir.pwd.untaint
+        start = here
+
+        begin
+          while true
+            path = GEM_DEP_FILES.find { |f| File.file?(f) }
+
+            if path
+              path = File.join here, path
+              break
+            end
+
+            Dir.chdir ".."
+
+            # If we're at a toplevel, stop.
+            return if Dir.pwd == here
+
+            here = Dir.pwd
+          end
+        ensure
+          Dir.chdir start
+        end
+      end
+
+      path.untaint
+
+      return unless File.file? path
+
+      rs = Gem::RequestSet.new
+      rs.load_gemdeps path
+
+      rs.resolve_current.map do |s|
+        sp = s.full_spec
+        sp.activate
+        sp
+      end
+    end
+  end
+
   ##
   # Find the full path to the executable for gem +name+.  If the +exec_name+
   # is not given, the gem's default_executable is chosen, otherwise the
@@ -258,6 +300,7 @@ module Gem
   # The path where gem executables are to be installed.
 
   def self.bindir(install_dir=Gem.dir)
+    # TODO: move to Gem::Dirs
     return File.join install_dir, 'bin' unless
       install_dir.to_s == Gem.default_dir.to_s
     Gem.default_bindir
@@ -317,21 +360,16 @@ module Gem
     Zlib::Deflate.deflate data
   end
 
-  # Retrieve the PathSupport object that RubyGems uses to
-  # lookup files.
-
+  # DOC: needs doc'd or :nodoc'd
   def self.paths
     @paths ||= Gem::PathSupport.new
   end
 
-  # Initialize the filesystem paths to use from +env+.
-  # +env+ is a hash-like object (typically ENV) that
-  # is queried for 'GEM_HOME', 'GEM_PATH', and 'GEM_SPEC_CACHE'
-
+  # DOC: needs doc'd or :nodoc'd
   def self.paths=(env)
     clear_paths
     @paths = Gem::PathSupport.new env
-    Gem::Specification.dirs = @paths.path
+    Gem::Specification.dirs = @paths.path # FIX: home is at end
   end
 
   ##
@@ -340,10 +378,12 @@ module Gem
   # FIXME deprecate these once everything else has been done -ebh
 
   def self.dir
+    # TODO: raise "no"
     paths.home
   end
 
   def self.path
+    # TODO: raise "no"
     paths.path
   end
 
@@ -397,18 +437,6 @@ module Gem
   end
 
   ##
-  # The extension API version of ruby.  This includes the static vs non-static
-  # distinction as extensions cannot be shared between the two.
-
-  def self.extension_api_version # :nodoc:
-    if 'no' == RbConfig::CONFIG['ENABLE_SHARED'] then
-      "#{ruby_api_version}-static"
-    else
-      ruby_api_version
-    end
-  end
-
-  ##
   # Returns a list of paths matching +glob+ that can be used by a gem to pick
   # up features from other gems.  For example:
   #
@@ -510,30 +538,42 @@ module Gem
 
   private_class_method :find_home
 
-  # FIXME deprecate these in 3.0
-
   ##
   # Zlib::GzipReader wrapper that unzips +data+.
 
   def self.gunzip(data)
-    require 'rubygems/util'
-    Gem::Util.gunzip data
+    # TODO: move to utils
+    require 'stringio'
+    require 'zlib'
+    data = StringIO.new data
+
+    unzipped = Zlib::GzipReader.new(data).read
+    unzipped.force_encoding Encoding::BINARY if Object.const_defined? :Encoding
+    unzipped
   end
 
   ##
   # Zlib::GzipWriter wrapper that zips +data+.
 
   def self.gzip(data)
-    require 'rubygems/util'
-    Gem::Util.gzip data
+    # TODO: move to utils
+    require 'stringio'
+    require 'zlib'
+    zipped = StringIO.new
+    zipped.set_encoding Encoding::BINARY if Object.const_defined? :Encoding
+
+    Zlib::GzipWriter.wrap zipped do |io| io.write data end
+
+    zipped.string
   end
 
   ##
   # A Zlib::Inflate#inflate wrapper
 
   def self.inflate(data)
-    require 'rubygems/util'
-    Gem::Util.inflate data
+    # TODO: move to utils
+    require 'zlib'
+    Zlib::Inflate.inflate data
   end
 
   ##
@@ -568,11 +608,14 @@ module Gem
   end
 
   ##
-  # The index to insert activated gem paths into the $LOAD_PATH. The activated
-  # gem's paths are inserted before site lib directory by default.
+  # The index to insert activated gem paths into the $LOAD_PATH.
+  #
+  # Defaults to the site lib directory unless gem_prelude.rb has loaded paths,
+  # then it inserts the activated gem's paths before the gem_prelude.rb paths
+  # so you can override the gem_prelude.rb default $LOAD_PATH paths.
 
   def self.load_path_insert_index
-    index = $LOAD_PATH.index RbConfig::CONFIG['sitelibdir']
+    index = $LOAD_PATH.index ConfigMap[:sitelibdir]
 
     index
   end
@@ -636,6 +679,7 @@ module Gem
     file = $1
     lineno = $2.to_i
 
+    # TODO: it is ALWAYS joined! STUPID!
     [file, lineno]
   end
 
@@ -743,8 +787,8 @@ module Gem
   def self.prefix
     prefix = File.dirname RUBYGEMS_DIR
 
-    if prefix != File.expand_path(RbConfig::CONFIG['sitelibdir']) and
-       prefix != File.expand_path(RbConfig::CONFIG['libdir']) and
+    if prefix != File.expand_path(ConfigMap[:sitelibdir]) and
+       prefix != File.expand_path(ConfigMap[:libdir]) and
        'lib' == File.basename(RUBYGEMS_DIR) then
       prefix
     end
@@ -761,14 +805,7 @@ module Gem
   # Safely read a file in binary mode on all platforms.
 
   def self.read_binary(path)
-    open path, 'rb+' do |f|
-      f.flock(File::LOCK_EX)
-      f.read
-    end
-  rescue Errno::EACCES
-    open path, 'rb' do |f|
-      f.read
-    end
+    File.open path, binary_mode do |f| f.read end
   end
 
   ##
@@ -776,8 +813,8 @@ module Gem
 
   def self.ruby
     if @ruby.nil? then
-      @ruby = File.join(RbConfig::CONFIG['bindir'],
-                        "#{RbConfig::CONFIG['ruby_install_name']}#{RbConfig::CONFIG['EXEEXT']}")
+      @ruby = File.join(ConfigMap[:bindir],
+                        "#{ConfigMap[:ruby_install_name]}#{ConfigMap[:EXEEXT]}")
 
       @ruby = "\"#{@ruby}\"" if @ruby =~ /\s/
     end
@@ -786,13 +823,6 @@ module Gem
   end
 
   ##
-  # Returns a String containing the API compatibility version of Ruby
-
-  def self.ruby_api_version
-    @ruby_api_version ||= RbConfig::CONFIG['ruby_version'].dup
-  end
-
-  ##
   # Returns the latest release-version specification for the gem +name+.
 
   def self.latest_spec_for name
@@ -922,6 +952,7 @@ module Gem
     paths = nil if paths == [nil]
     paths = paths.first if Array === Array(paths).first
     self.paths = { "GEM_HOME" => home, "GEM_PATH" => paths }
+    # TODO: self.paths = home, paths
   end
 
   ##
@@ -994,56 +1025,6 @@ module Gem
     load_plugin_files files
   end
 
-  ##
-  # Looks for gem dependency files (gem.deps.rb, Gemfile, Isolate) from the
-  # current directory up and activates the gems in the first file found.
-  #
-  # You can run this automatically when rubygems starts.  To enable, set
-  # the <code>RUBYGEMS_GEMDEPS</code> environment variable to either the path
-  # of your Gemfile or "-" to auto-discover in parent directories.
-  #
-  # NOTE: Enabling automatic discovery on multiuser systems can lead to
-  # execution of arbitrary code when used from directories outside your
-  # control.
-
-  def self.use_gemdeps
-    return unless path = ENV['RUBYGEMS_GEMDEPS']
-    path = path.dup
-
-    if path == "-" then
-      require 'rubygems/util'
-
-      Gem::Util.traverse_parents Dir.pwd do |directory|
-        dep_file = GEM_DEP_FILES.find { |f| File.file?(f) }
-
-        next unless dep_file
-
-        path = File.join directory, dep_file
-        break
-      end
-    end
-
-    path.untaint
-
-    return unless File.file? path
-
-    rs = Gem::RequestSet.new
-    rs.load_gemdeps path
-
-    rs.resolve_current.map do |s|
-      sp = s.full_spec
-      sp.activate
-      sp
-    end
-  end
-
-  class << self
-    ##
-    # TODO remove with RubyGems 3.0
-
-    alias detect_gemdeps use_gemdeps # :nodoc:
-  end
-
   # FIX: Almost everywhere else we use the `def self.` way of defining class
   # methods, and then we switch over to `class << self` here. Pick one or the
   # other.
@@ -1106,7 +1087,7 @@ module Gem
     end
 
     ##
-    # Clear default gem related variables. It is for test
+    # Clear default gem related varibles. It is for test
 
     def clear_default_specs
       @path_to_default_spec_map.clear
@@ -1166,18 +1147,16 @@ module Gem
   autoload :ConfigFile,         'rubygems/config_file'
   autoload :Dependency,         'rubygems/dependency'
   autoload :DependencyList,     'rubygems/dependency_list'
-  autoload :DependencyResolver, 'rubygems/resolver'
-  autoload :Installer,          'rubygems/installer'
+  autoload :DependencyResolver, 'rubygems/dependency_resolver'
   autoload :PathSupport,        'rubygems/path_support'
   autoload :Platform,           'rubygems/platform'
   autoload :RequestSet,         'rubygems/request_set'
   autoload :Requirement,        'rubygems/requirement'
-  autoload :Resolver,           'rubygems/resolver'
-  autoload :Source,             'rubygems/source'
   autoload :SourceList,         'rubygems/source_list'
   autoload :SpecFetcher,        'rubygems/spec_fetcher'
   autoload :Specification,      'rubygems/specification'
   autoload :Version,            'rubygems/version'
+  autoload :Source,             'rubygems/source'
 
   require "rubygems/specification"
 end
@@ -1213,5 +1192,4 @@ Gem::Specification.load_defaults
 require 'rubygems/core_ext/kernel_gem'
 require 'rubygems/core_ext/kernel_require'
 
-Gem.use_gemdeps
-
+Gem.detect_gemdeps
diff --git a/lib/rubygems/available_set.rb b/lib/rubygems/available_set.rb
index fabdd6e..bb0b3a3 100644
--- a/lib/rubygems/available_set.rb
+++ b/lib/rubygems/available_set.rb
@@ -4,12 +4,9 @@ class Gem::AvailableSet
 
   Tuple = Struct.new(:spec, :source)
 
-  attr_accessor :remote # :nodoc:
-
   def initialize
     @set = []
     @sorted = nil
-    @remote = true
   end
 
   attr_reader :set
@@ -119,7 +116,7 @@ class Gem::AvailableSet
 
   ##
   #
-  # Used by the Resolver, the protocol to use a AvailableSet as a
+  # Used by the DependencyResolver, the protocol to use a AvailableSet as a
   # search Set.
 
   def find_all(req)
@@ -130,7 +127,7 @@ class Gem::AvailableSet
     end
 
     match.map do |t|
-      Gem::Resolver::LocalSpecification.new(self, t.spec, t.source)
+      Gem::DependencyResolver::InstalledSpecification.new(self, t.spec, t.source)
     end
   end
 
diff --git a/lib/rubygems/basic_specification.rb b/lib/rubygems/basic_specification.rb
index 470a6eb..24bb4bc 100644
--- a/lib/rubygems/basic_specification.rb
+++ b/lib/rubygems/basic_specification.rb
@@ -5,25 +5,10 @@
 class Gem::BasicSpecification
 
   ##
-  # Allows installation of extensions for git: gems.
-
-  attr_writer :base_dir # :nodoc:
-
-  ##
-  # Sets the directory where extensions for this gem will be installed.
-
-  attr_writer :extension_dir # :nodoc:
-
-  ##
   # The path this gemspec was loaded from.  This attribute is not persisted.
 
   attr_reader :loaded_from
 
-  ##
-  # Allows correct activation of git: and path: gems.
-
-  attr_writer :full_gem_path # :nodoc:
-
   def self.default_specifications_dir
     File.join(Gem.default_dir, "specifications", "default")
   end
@@ -53,12 +38,11 @@ class Gem::BasicSpecification
   # Return true if this spec can require +file+.
 
   def contains_requirable_file? file
-    build_extensions
-
+    root     = full_gem_path
     suffixes = Gem.suffixes
 
-    full_require_paths.any? do |dir|
-      base = "#{dir}/#{file}"
+    require_paths.any? do |lib|
+      base = "#{root}/#{lib}/#{file}"
       suffixes.any? { |suf| File.file? "#{base}#{suf}" }
     end
   end
@@ -68,22 +52,6 @@ class Gem::BasicSpecification
       File.dirname(loaded_from) == self.class.default_specifications_dir
   end
 
-  ##
-  # Returns full path to the directory where gem's extensions are installed.
-
-  def extension_dir
-    @extension_dir ||= File.expand_path File.join(extensions_dir, full_name)
-  end
-
-  ##
-  # Returns path to the extensions directory.
-
-  def extensions_dir
-    @extensions_dir ||= Gem.default_ext_dir_for(base_dir) ||
-      File.join(base_dir, 'extensions', Gem::Platform.local.to_s,
-                Gem.extension_api_version)
-  end
-
   def find_full_gem_path # :nodoc:
     # TODO: also, shouldn't it default to full_name if it hasn't been written?
     path = File.expand_path File.join(gems_dir, full_name)
@@ -116,28 +84,6 @@ class Gem::BasicSpecification
   end
 
   ##
-  # Full paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
-  # activated.
-
-  def full_require_paths
-    full_paths = @require_paths.map do |path|
-      File.join full_gem_path, path
-    end
-
-    full_paths.unshift extension_dir unless @extensions.empty?
-
-    full_paths
-  end
-
-  ##
-  # Returns the full path to this spec's gem directory.
-  # eg: /usr/local/lib/ruby/1.8/gems/mygem-1.0
-
-  def gem_dir
-    @gem_dir ||= File.expand_path File.join(gems_dir, full_name)
-  end
-
-  ##
   # Returns the full path to the gems directory containing this spec's
   # gem directory. eg: /usr/local/lib/ruby/1.8/gems
 
@@ -153,12 +99,9 @@ class Gem::BasicSpecification
   def loaded_from= path
     @loaded_from   = path && path.to_s
 
-    @extension_dir = nil
-    @extensions_dir = nil
-    @full_gem_path         = nil
-    @gem_dir               = nil
-    @gems_dir              = nil
-    @base_dir              = nil
+    @full_gem_path = nil
+    @gems_dir      = nil
+    @base_dir      = nil
   end
 
   ##
@@ -175,53 +118,11 @@ class Gem::BasicSpecification
     raise NotImplementedError
   end
 
-  def raw_require_paths # :nodoc:
-    @require_paths
-  end
-
   ##
-  # Paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
-  # activated.
-  #
-  # See also #require_paths=
-  #
-  # If you have an extension you do not need to add <code>"ext"</code> to the
-  # require path, the extension build process will copy the extension files
-  # into "lib" for you.
-  #
-  # The default value is <code>"lib"</code>
-  #
-  # Usage:
-  #
-  #   # If all library files are in the root directory...
-  #   spec.require_path = '.'
+  # Require paths of the gem
 
   def require_paths
-    return @require_paths if @extensions.empty?
-
-    relative_extension_dir =
-      File.join '..', '..', 'extensions', Gem::Platform.local.to_s,
-                Gem.extension_api_version, full_name
-
-    [relative_extension_dir].concat @require_paths
-  end
-
-  ##
-  # Returns the paths to the source files for use with analysis and
-  # documentation tools.  These paths are relative to full_gem_path.
-
-  def source_paths
-    paths = raw_require_paths.dup
-
-    if @extensions then
-      ext_dirs = @extensions.map do |extension|
-        extension.split(File::SEPARATOR, 2).first
-      end.uniq
-
-      paths.concat ext_dirs
-    end
-
-    paths.uniq
+    raise NotImplementedError
   end
 
   ##
@@ -238,13 +139,5 @@ class Gem::BasicSpecification
     raise NotImplementedError
   end
 
-  ##
-  # Whether this specification is stubbed - i.e. we have information
-  # about the gem from a stub line, without having to evaluate the
-  # entire gemspec file.
-  def stubbed?
-    raise NotImplementedError
-  end
-
 end
 
diff --git a/lib/rubygems/commands/contents_command.rb b/lib/rubygems/commands/contents_command.rb
index 603f1d0..9721884 100644
--- a/lib/rubygems/commands/contents_command.rb
+++ b/lib/rubygems/commands/contents_command.rb
@@ -94,11 +94,11 @@ prefix or only the files that are requireable.
     spec.files.sort.map do |file|
       case file
       when /\A#{spec.bindir}\//
-        [RbConfig::CONFIG['bindir'], $POSTMATCH]
+        [Gem::ConfigMap[:bindir], $POSTMATCH]
       when /\.so\z/
-        [RbConfig::CONFIG['archdir'], file]
+        [Gem::ConfigMap[:archdir], file]
       else
-        [RbConfig::CONFIG['rubylibdir'], file]
+        [Gem::ConfigMap[:rubylibdir], file]
       end
     end
   end
diff --git a/lib/rubygems/commands/generate_index_command.rb b/lib/rubygems/commands/generate_index_command.rb
index ca6f694..a7db013 100644
--- a/lib/rubygems/commands/generate_index_command.rb
+++ b/lib/rubygems/commands/generate_index_command.rb
@@ -62,7 +62,7 @@ Marshal::MINOR_VERSION constants.  It is used to ensure compatibility.
   end
 
   def execute
-    # This is always true because it's the only way now.
+    # This is always true becasue it's the only way now.
     options[:build_modern] = true
 
     if not File.exist?(options[:directory]) or
diff --git a/lib/rubygems/commands/install_command.rb b/lib/rubygems/commands/install_command.rb
index 8219eef..f02b129 100644
--- a/lib/rubygems/commands/install_command.rb
+++ b/lib/rubygems/commands/install_command.rb
@@ -22,7 +22,6 @@ class Gem::Commands::InstallCommand < Gem::Command
     defaults = Gem::DependencyInstaller::DEFAULT_OPTIONS.merge({
       :format_executable => false,
       :version           => Gem::Requirement.default,
-      :without_groups    => [],
     })
 
     super 'install', 'Install a gem into the local repository', defaults
@@ -33,43 +32,19 @@ class Gem::Commands::InstallCommand < Gem::Command
     add_version_option
     add_prerelease_option "to be installed. (Only for listed gems)"
 
-    add_option(:"Install/Update", '-g', '--file [FILE]',
+    add_option(:"Install/Update", '-g', '--file FILE',
                'Read from a gem dependencies API file and',
                'install the listed gems') do |v,o|
-      v = Gem::GEM_DEP_FILES.find do |file|
-        File.exist? file
-      end unless v
-
-      unless v then
-        message = v ? v : "(tried #{Gem::GEM_DEP_FILES.join ', '})"
-
-        raise OptionParser::InvalidArgument,
-                "cannot find gem dependencies file #{message}"
-      end
-
       o[:gemdeps] = v
     end
 
-    add_option(:"Install/Update", '--without GROUPS', Array,
-               'Omit the named groups (comma separated)',
-               'when installing from a gem dependencies',
-               'file') do |v,o|
-      o[:without_groups].concat v.map { |without| without.intern }
-    end
-
     add_option(:"Install/Update", '--default',
                'Add the gem\'s full specification to',
                'specifications/default and extract only its bin') do |v,o|
       o[:install_as_default] = v
     end
 
-    add_option(:"Install/Update", '--explain',
-               'Rather than install the gems, indicate which would',
-               'be installed') do |v,o|
-      o[:explain] = v
-    end
-
-    @installed_specs = []
+    @installed_specs = nil
   end
 
   def arguments # :nodoc:
@@ -154,9 +129,9 @@ to write the specification by hand.  For example:
   end
 
   def execute
-    if options.include? :gemdeps then
-      install_from_gemdeps
-      return # not reached
+    if gf = options[:gemdeps] then
+      install_from_gemdeps gf
+      return
     end
 
     @installed_specs = []
@@ -172,14 +147,17 @@ to write the specification by hand.  For example:
 
     show_installed
 
-    terminate_interaction exit_code
+    raise Gem::SystemExitException, exit_code
   end
 
-  def install_from_gemdeps # :nodoc:
+  def install_from_gemdeps gf # :nodoc:
     require 'rubygems/request_set'
     rs = Gem::RequestSet.new
+    rs.load_gemdeps gf
+
+    rs.resolve
 
-    specs = rs.install_from_gemdeps options do |req, inst|
+    specs = rs.install options do |req, inst|
       s = req.full_spec
 
       if inst
@@ -191,66 +169,19 @@ to write the specification by hand.  For example:
 
     @installed_specs = specs
 
-    terminate_interaction
+    raise Gem::SystemExitException, 0
   end
 
   def install_gem name, version # :nodoc:
     return if options[:conservative] and
       not Gem::Dependency.new(name, version).matching_specs.empty?
 
-    req = Gem::Requirement.create(version)
-
-    if options[:ignore_dependencies] then
-      install_gem_without_dependencies name, req
-    else
-      inst = Gem::DependencyInstaller.new options
-
-      if options[:explain]
-        request_set = inst.resolve_dependencies name, req
-
-        puts "Gems to install:"
-
-        request_set.specs.map { |s| s.full_name }.sort.each do |s|
-          puts "  #{s}"
-        end
-
-        return
-      else
-        inst.install name, req
-      end
-
-      @installed_specs.push(*inst.installed_gems)
-
-      show_install_errors inst.errors
-    end
-  end
-
-  def install_gem_without_dependencies name, req # :nodoc:
-    gem = nil
-
-    if local? then
-      if name =~ /\.gem$/ and File.file? name then
-        source = Gem::Source::SpecificFile.new name
-        spec = source.spec
-      else
-        source = Gem::Source::Local.new
-        spec = source.find_gem name, req
-      end
-      gem = source.download spec if spec
-    end
-
-    if remote? and not gem then
-      dependency = Gem::Dependency.new name, req
-      dependency.prerelease = options[:prerelease]
-
-      fetcher = Gem::RemoteFetcher.fetcher
-      gem = fetcher.download_to_cache dependency
-    end
+    inst = Gem::DependencyInstaller.new options
+    inst.install name, Gem::Requirement.create(version)
 
-    inst = Gem::Installer.new gem, options
-    inst.install
+    @installed_specs.push(*inst.installed_gems)
 
-    @installed_specs.push(inst.spec)
+    show_install_errors inst.errors
   end
 
   def install_gems # :nodoc:
diff --git a/lib/rubygems/commands/list_command.rb b/lib/rubygems/commands/list_command.rb
index 4edeabe..0d15950 100644
--- a/lib/rubygems/commands/list_command.rb
+++ b/lib/rubygems/commands/list_command.rb
@@ -33,7 +33,13 @@ To search for remote gems use the search command.
   end
 
   def usage # :nodoc:
-    "#{program_name} [STRING ...]"
+    "#{program_name} [STRING]"
+  end
+
+  def execute
+    string = get_one_optional_argument || ''
+    options[:name] = /^#{string}/i
+    super
   end
 
 end
diff --git a/lib/rubygems/commands/outdated_command.rb b/lib/rubygems/commands/outdated_command.rb
index 7159dbb..f51bc5e 100644
--- a/lib/rubygems/commands/outdated_command.rb
+++ b/lib/rubygems/commands/outdated_command.rb
@@ -17,7 +17,7 @@ class Gem::Commands::OutdatedCommand < Gem::Command
 
   def description # :nodoc:
     <<-EOF
-The outdated command lists gems you may wish to upgrade to a newer version.
+The outdated command lists gems you way wish to upgrade to a newer version.
 
 You can check for dependency mismatches using the dependency command and
 update the gems with the update or install commands.
diff --git a/lib/rubygems/commands/pristine_command.rb b/lib/rubygems/commands/pristine_command.rb
index b54e7ea..3f3bca4 100644
--- a/lib/rubygems/commands/pristine_command.rb
+++ b/lib/rubygems/commands/pristine_command.rb
@@ -12,7 +12,6 @@ class Gem::Commands::PristineCommand < Gem::Command
           'Restores installed gems to pristine condition from files located in the gem cache',
           :version => Gem::Requirement.default,
           :extensions => true,
-          :extensions_set => false,
           :all => false
 
     add_option('--all',
@@ -24,8 +23,7 @@ class Gem::Commands::PristineCommand < Gem::Command
     add_option('--[no-]extensions',
                'Restore gems with extensions',
                'in addition to regular gems') do |value, options|
-      options[:extensions_set] = true
-      options[:extensions]     = value
+      options[:extensions] = value
     end
 
     add_option('--only-executables',
@@ -64,9 +62,6 @@ If the cached gem cannot be found it will be downloaded.
 
 If --no-extensions is provided pristine will not attempt to restore a gem
 with an extension.
-
-If --extensions is given (but not --all or gem names) only gems with
-extensions will be restored.
     EOF
   end
 
@@ -77,14 +72,6 @@ extensions will be restored.
   def execute
     specs = if options[:all] then
               Gem::Specification.map
-
-            # `--extensions` must be explicitly given to pristine only gems
-            # with extensions.
-            elsif options[:extensions_set] and
-                  options[:extensions] and options[:args].empty? then
-              Gem::Specification.select do |spec|
-                spec.extensions and not spec.extensions.empty?
-              end
             else
               get_all_gem_names.map do |gem_name|
                 Gem::Specification.find_all_by_name gem_name, options[:version]
diff --git a/lib/rubygems/commands/push_command.rb b/lib/rubygems/commands/push_command.rb
index 6899b48..b90be7b 100644
--- a/lib/rubygems/commands/push_command.rb
+++ b/lib/rubygems/commands/push_command.rb
@@ -69,18 +69,13 @@ You can upgrade or downgrade to the latest release version with:
       terminate_interaction 1
     end
 
-    gem_data = Gem::Package.new(name)
-
     unless @host then
-      @host = gem_data.spec.metadata['default_gem_server']
+      if gem_data = Gem::Package.new(name) then
+        @host = gem_data.spec.metadata['default_gem_server']
+      end
     end
 
-    # Always include this, even if it's nil
-    args << @host
-
-    if gem_data.spec.metadata.has_key?('allowed_push_host')
-      args << gem_data.spec.metadata['allowed_push_host']
-    end
+    args << @host if @host
 
     say "Pushing gem to #{@host || Gem.host}..."
 
diff --git a/lib/rubygems/commands/query_command.rb b/lib/rubygems/commands/query_command.rb
index 432250e..c9c3014 100644
--- a/lib/rubygems/commands/query_command.rb
+++ b/lib/rubygems/commands/query_command.rb
@@ -72,26 +72,16 @@ is too hard to use.
 
   def execute
     exit_code = 0
-    if options[:args].to_a.empty? and options[:name].source.empty?
-      name = options[:name]
-      no_name = true
-    elsif !options[:name].source.empty?
-      name = Array(options[:name])
-    else
-      name = options[:args].to_a.map{|arg| /#{arg}/i }
-    end
 
+    name = options[:name]
     prerelease = options[:prerelease]
 
     unless options[:installed].nil? then
-      if no_name then
+      if name.source.empty? then
         alert_error "You must specify a gem name"
         exit_code |= 4
-      elsif name.count > 1
-        alert_error "You must specify only ONE gem!"
-        exit_code |= 4
       else
-        installed = installed? name.first, options[:version]
+        installed = installed? name, options[:version]
         installed = !installed unless options[:installed]
 
         if installed then
@@ -105,22 +95,6 @@ is too hard to use.
       terminate_interaction exit_code
     end
 
-    names = Array(name)
-    names.each { |n| show_gems n, prerelease }
-  end
-
-  private
-
-  def display_header type
-    if (ui.outs.tty? and Gem.configuration.verbose) or both? then
-      say
-      say "*** #{type} GEMS ***"
-      say
-    end
-  end
-
-  #Guts of original execute
-  def show_gems name, prerelease
     req = Gem::Requirement.default
     # TODO: deprecate for real
     dep = Gem::Deprecate.skip_during { Gem::Dependency.new name, req }
@@ -131,7 +105,11 @@ is too hard to use.
         alert_warning "prereleases are always shown locally"
       end
 
-      display_header 'LOCAL'
+      if ui.outs.tty? or both? then
+        say
+        say "*** LOCAL GEMS ***"
+        say
+      end
 
       specs = Gem::Specification.find_all { |s|
         s.name =~ name and req =~ s.version
@@ -145,7 +123,11 @@ is too hard to use.
     end
 
     if remote? then
-      display_header 'REMOTE'
+      if ui.outs.tty? or both? then
+        say
+        say "*** REMOTE GEMS ***"
+        say
+      end
 
       fetcher = Gem::SpecFetcher.fetcher
 
@@ -161,11 +143,11 @@ is too hard to use.
                :latest
              end
 
-      if name.source.empty?
+      if options[:name].source.empty?
         spec_tuples = fetcher.detect(type) { true }
       else
         spec_tuples = fetcher.detect(type) do |name_tuple|
-          name === name_tuple.name
+          options[:name] === name_tuple.name
         end
       end
 
@@ -173,6 +155,8 @@ is too hard to use.
     end
   end
 
+  private
+
   ##
   # Check if gem +name+ version +version+ is installed.
 
diff --git a/lib/rubygems/commands/search_command.rb b/lib/rubygems/commands/search_command.rb
index 5809690..5bc9650 100644
--- a/lib/rubygems/commands/search_command.rb
+++ b/lib/rubygems/commands/search_command.rb
@@ -36,5 +36,11 @@ To list local gems use the list command.
     "#{program_name} [STRING]"
   end
 
+  def execute
+    string = get_one_optional_argument
+    options[:name] = /#{string}/i
+    super
+  end
+
 end
 
diff --git a/lib/rubygems/commands/setup_command.rb b/lib/rubygems/commands/setup_command.rb
index 681db0d..face77f 100644
--- a/lib/rubygems/commands/setup_command.rb
+++ b/lib/rubygems/commands/setup_command.rb
@@ -13,7 +13,7 @@ class Gem::Commands::SetupCommand < Gem::Command
 
     super 'setup', 'Install RubyGems',
           :format_executable => true, :document => %w[ri],
-          :site_or_vendor => 'sitelibdir',
+          :site_or_vendor => :sitelibdir,
           :destdir => '', :prefix => '', :previous_version => ''
 
     add_option '--previous-version=VERSION',
@@ -36,7 +36,7 @@ class Gem::Commands::SetupCommand < Gem::Command
 
     add_option '--[no-]vendor',
                'Install into vendorlibdir not sitelibdir' do |vendor, options|
-      options[:site_or_vendor] = vendor ? 'vendorlibdir' : 'sitelibdir'
+      options[:site_or_vendor] = vendor ? :vendorlibdir : :sitelibdir
     end
 
     add_option '--[no-]format-executable',
@@ -343,19 +343,19 @@ TEXT
     site_or_vendor = options[:site_or_vendor]
 
     if prefix.empty? then
-      lib_dir = RbConfig::CONFIG[site_or_vendor]
-      bin_dir = RbConfig::CONFIG['bindir']
+      lib_dir = Gem::ConfigMap[site_or_vendor]
+      bin_dir = Gem::ConfigMap[:bindir]
     else
       # Apple installed RubyGems into libdir, and RubyGems <= 1.1.0 gets
       # confused about installation location, so switch back to
       # sitelibdir/vendorlibdir.
       if defined?(APPLE_GEM_HOME) and
         # just in case Apple and RubyGems don't get this patched up proper.
-        (prefix == RbConfig::CONFIG['libdir'] or
+        (prefix == Gem::ConfigMap[:libdir] or
          # this one is important
-         prefix == File.join(RbConfig::CONFIG['libdir'], 'ruby')) then
-         lib_dir = RbConfig::CONFIG[site_or_vendor]
-         bin_dir = RbConfig::CONFIG['bindir']
+         prefix == File.join(Gem::ConfigMap[:libdir], 'ruby')) then
+         lib_dir = Gem::ConfigMap[site_or_vendor]
+         bin_dir = Gem::ConfigMap[:bindir]
       else
         lib_dir = File.join prefix, 'lib'
         bin_dir = File.join prefix, 'bin'
diff --git a/lib/rubygems/commands/specification_command.rb b/lib/rubygems/commands/specification_command.rb
index 3bc02a9..d96c8b8 100644
--- a/lib/rubygems/commands/specification_command.rb
+++ b/lib/rubygems/commands/specification_command.rb
@@ -127,7 +127,7 @@ Specific fields in the specification can be extracted in YAML format:
     end
 
     unless options[:all] then
-      specs = [specs.max_by { |s| s.version }]
+      specs = [specs.sort_by { |s| s.version }.last]
     end
 
     specs.each do |s|
diff --git a/lib/rubygems/commands/unpack_command.rb b/lib/rubygems/commands/unpack_command.rb
index 5a05ad0..e60e7d9 100644
--- a/lib/rubygems/commands/unpack_command.rb
+++ b/lib/rubygems/commands/unpack_command.rb
@@ -134,7 +134,7 @@ command help for an example.
 
     specs = dependency.matching_specs
 
-    selected = specs.max_by { |s| s.version }
+    selected = specs.sort_by { |s| s.version }.last # HACK: hunt last down
 
     return Gem::RemoteFetcher.fetcher.download_to_cache(dependency) unless
       selected
diff --git a/lib/rubygems/commands/update_command.rb b/lib/rubygems/commands/update_command.rb
index b4ee59b..8e65517 100644
--- a/lib/rubygems/commands/update_command.rb
+++ b/lib/rubygems/commands/update_command.rb
@@ -138,7 +138,7 @@ command to remove old versions.
       g.name == spec.name and g.match_platform?
     end
 
-    highest_remote_gem = matching_gems.max_by { |g,_| g.version }
+    highest_remote_gem = matching_gems.sort_by { |g,_| g.version }.last
 
     highest_remote_gem ||= [Gem::NameTuple.null]
 
@@ -248,9 +248,6 @@ command to remove old versions.
     args << '--no-rdoc' unless options[:document].include? 'rdoc'
     args << '--no-ri'   unless options[:document].include? 'ri'
     args << '--no-format-executable' if options[:no_format_executable]
-    args << '--previous-version' << Gem::VERSION if
-      options[:system] == true or
-        Gem::Version.new(options[:system]) >= Gem::Version.new(2)
     args
   end
 
diff --git a/lib/rubygems/commands/which_command.rb b/lib/rubygems/commands/which_command.rb
index 96eeb86..99b9085 100644
--- a/lib/rubygems/commands/which_command.rb
+++ b/lib/rubygems/commands/which_command.rb
@@ -35,7 +35,7 @@ requiring to see why it does not behave as you expect.
   end
 
   def execute
-    found = true
+    found = false
 
     options[:args].each do |arg|
       arg = arg.sub(/#{Regexp.union(*Gem.suffixes)}$/, '')
@@ -45,9 +45,9 @@ requiring to see why it does not behave as you expect.
 
       if spec then
         if options[:search_gems_first] then
-          dirs = spec.full_require_paths + $LOAD_PATH
+          dirs = gem_paths(spec) + $LOAD_PATH
         else
-          dirs = $LOAD_PATH + spec.full_require_paths
+          dirs = $LOAD_PATH + gem_paths(spec)
         end
       end
 
@@ -56,10 +56,9 @@ requiring to see why it does not behave as you expect.
 
       if paths.empty? then
         alert_error "Can't find ruby library file or shared library #{arg}"
-
-        found &&= false
       else
         say paths
+        found = true
       end
     end
 
@@ -82,6 +81,10 @@ requiring to see why it does not behave as you expect.
     result
   end
 
+  def gem_paths(spec)
+    spec.require_paths.collect { |d| File.join spec.full_gem_path, d }
+  end
+
   def usage # :nodoc:
     "#{program_name} FILE [FILE ...]"
   end
diff --git a/lib/rubygems/compatibility.rb b/lib/rubygems/compatibility.rb
index d06ade1..87d5672 100644
--- a/lib/rubygems/compatibility.rb
+++ b/lib/rubygems/compatibility.rb
@@ -33,12 +33,7 @@ end
 module Gem
   RubyGemsVersion = VERSION
 
-  # TODO remove at RubyGems 3
-
   RbConfigPriorities = %w[
-    MAJOR
-    MINOR
-    TEENY
     EXEEXT RUBY_SO_NAME arch bindir datadir libdir ruby_install_name
     ruby_version rubylibprefix sitedir sitelibdir vendordir vendorlibdir
     rubylibdir
@@ -47,7 +42,7 @@ module Gem
   unless defined?(ConfigMap)
     ##
     # Configuration settings from ::RbConfig
-    ConfigMap = Hash.new do |cm, key| # TODO remove at RubyGems 3
+    ConfigMap = Hash.new do |cm, key|
       cm[key] = RbConfig::CONFIG[key.to_s]
     end
   else
diff --git a/lib/rubygems/config_file.rb b/lib/rubygems/config_file.rb
index cf14017..1acae9b 100644
--- a/lib/rubygems/config_file.rb
+++ b/lib/rubygems/config_file.rb
@@ -137,10 +137,9 @@ class Gem::ConfigFile
   attr_reader :ssl_verify_mode
 
   ##
-  # Path name of directory or file of openssl CA certificate, used for remote
-  # https connection
+  # Path name of directory or file of openssl CA certificate, used for remote https connection
 
-  attr_accessor :ssl_ca_cert
+  attr_reader :ssl_ca_cert
 
   ##
   # Path name of directory or file of openssl client certificate, used for remote https connection with client authentication
diff --git a/lib/rubygems/core_ext/kernel_gem.rb b/lib/rubygems/core_ext/kernel_gem.rb
index 3405233..f946d0d 100644
--- a/lib/rubygems/core_ext/kernel_gem.rb
+++ b/lib/rubygems/core_ext/kernel_gem.rb
@@ -1,9 +1,3 @@
-##
-# RubyGems adds the #gem method to allow activation of specific gem versions
-# and overrides the #require method on Kernel to make gems appear as if they
-# live on the <code>$LOAD_PATH</code>.  See the documentation of these methods
-# for further detail.
-
 module Kernel
 
   # REFACTOR: This should be pulled out into some kind of hacks file.
diff --git a/lib/rubygems/defaults.rb b/lib/rubygems/defaults.rb
index 6924f48..591580b 100644
--- a/lib/rubygems/defaults.rb
+++ b/lib/rubygems/defaults.rb
@@ -29,22 +29,22 @@ module Gem
   def self.default_dir
     path = if defined? RUBY_FRAMEWORK_VERSION then
              [
-               File.dirname(RbConfig::CONFIG['sitedir']),
+               File.dirname(ConfigMap[:sitedir]),
                'Gems',
-               RbConfig::CONFIG['ruby_version']
+               ConfigMap[:ruby_version]
              ]
-           elsif RbConfig::CONFIG['rubylibprefix'] then
+           elsif ConfigMap[:rubylibprefix] then
              [
-              RbConfig::CONFIG['rubylibprefix'],
+              ConfigMap[:rubylibprefix],
               'gems',
-              RbConfig::CONFIG['ruby_version']
+              ConfigMap[:ruby_version]
              ]
            else
              [
-               RbConfig::CONFIG['libdir'],
+               ConfigMap[:libdir],
                ruby_engine,
                'gems',
-               RbConfig::CONFIG['ruby_version']
+               ConfigMap[:ruby_version]
              ]
            end
 
@@ -52,17 +52,6 @@ module Gem
   end
 
   ##
-  # Returns binary extensions dir for specified RubyGems base dir or nil
-  # if such directory cannot be determined.
-  #
-  # By default, the binary extensions are located side by side with their
-  # Ruby counterparts, therefore nil is returned
-
-  def self.default_ext_dir_for base_dir
-    nil
-  end
-
-  ##
   # Paths where RubyGems' .rb files and bin files are installed
 
   def self.default_rubygems_dirs
@@ -74,7 +63,7 @@ module Gem
 
   def self.user_dir
     parts = [Gem.user_home, '.gem', ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    parts << ConfigMap[:ruby_version] unless ConfigMap[:ruby_version].empty?
     File.join parts
   end
 
@@ -100,7 +89,7 @@ module Gem
   # Deduce Ruby's --program-prefix and --program-suffix from its install name
 
   def self.default_exec_format
-    exec_format = RbConfig::CONFIG['ruby_install_name'].sub('ruby', '%s') rescue '%s'
+    exec_format = ConfigMap[:ruby_install_name].sub('ruby', '%s') rescue '%s'
 
     unless exec_format =~ /%s/ then
       raise Gem::Exception,
@@ -117,7 +106,7 @@ module Gem
     if defined? RUBY_FRAMEWORK_VERSION then # mac framework support
       '/usr/bin'
     else # generic install
-      RbConfig::CONFIG['bindir']
+      ConfigMap[:bindir]
     end
   end
 
@@ -152,12 +141,4 @@ module Gem
   def self.default_gems_use_full_paths?
     ruby_engine != 'ruby'
   end
-
-  ##
-  # Install extensions into lib as well as into the extension directory.
-
-  def self.install_extension_in_lib # :nodoc:
-    true
-  end
-
 end
diff --git a/lib/rubygems/dependency_installer.rb b/lib/rubygems/dependency_installer.rb
index da6994a..14b46de 100644
--- a/lib/rubygems/dependency_installer.rb
+++ b/lib/rubygems/dependency_installer.rb
@@ -1,5 +1,6 @@
 require 'rubygems'
 require 'rubygems/dependency_list'
+require 'rubygems/dependency_resolver'
 require 'rubygems/package'
 require 'rubygems/installer'
 require 'rubygems/spec_fetcher'
@@ -195,7 +196,7 @@ class Gem::DependencyInstaller
   # sources.  Gems are sorted with newer gems preferred over older gems, and
   # local gems preferred over remote gems.
 
-  def find_gems_with_sources dep, best_only=false # :nodoc:
+  def find_gems_with_sources dep # :nodoc:
     set = Gem::AvailableSet.new
 
     if consider_local?
@@ -210,26 +211,7 @@ class Gem::DependencyInstaller
 
     if consider_remote?
       begin
-        # TODO this is pulled from #spec_for_dependency to allow
-        # us to filter tuples before fetching specs.
-        #
-        tuples, errors = Gem::SpecFetcher.fetcher.search_for_dependency dep
-
-        if best_only && !tuples.empty?
-          tuples.sort! { |a,b| b[0].version <=> a[0].version }
-          tuples = [tuples.first]
-        end
-
-        specs = []
-        tuples.each do |tup, source|
-          begin
-            spec = source.fetch_spec(tup)
-          rescue Gem::RemoteFetcher::FetchError => e
-            errors << Gem::SourceFetchProblem.new(source, e)
-          else
-            specs << [spec, source]
-          end
-        end
+        found, errors = Gem::SpecFetcher.fetcher.spec_for_dependency dep
 
         if @errors
           @errors += errors
@@ -237,7 +219,7 @@ class Gem::DependencyInstaller
           @errors = errors
         end
 
-        set << specs
+        set << found
 
       rescue Gem::RemoteFetcher::FetchError => e
         # FIX if there is a problem talking to the network, we either need to always tell
@@ -289,7 +271,7 @@ class Gem::DependencyInstaller
       dep = Gem::Dependency.new gem_name, version
       dep.prerelease = true if prerelease
 
-      set = find_gems_with_sources(dep, true)
+      set = find_gems_with_sources(dep)
       set.match_platform!
     end
 
@@ -304,7 +286,7 @@ class Gem::DependencyInstaller
   # Gathers all dependencies necessary for the installation from local and
   # remote sources unless the ignore_dependencies was given.
   #--
-  # TODO remove at RubyGems 3
+  # TODO remove, no longer used
 
   def gather_dependencies # :nodoc:
     specs = @available.all_specs
@@ -419,19 +401,17 @@ class Gem::DependencyInstaller
 
     request_set = as.to_request_set install_development_deps
     request_set.soft_missing = @force
-    request_set.remote = false unless consider_remote?
 
-    installer_set = Gem::Resolver::InstallerSet.new @domain
+    installer_set = Gem::DependencyResolver::InstallerSet.new @domain
     installer_set.always_install.concat request_set.always_install
     installer_set.ignore_installed = @only_install_dir
 
     if @ignore_dependencies then
       installer_set.ignore_dependencies = true
-      request_set.ignore_dependencies   = true
-      request_set.soft_missing          = true
+      request_set.soft_missing = true
     end
 
-    composed_set = Gem::Resolver.compose_sets as, installer_set
+    composed_set = Gem::DependencyResolver.compose_sets as, installer_set
 
     request_set.resolve composed_set
 
diff --git a/lib/rubygems/dependency_resolver.rb b/lib/rubygems/dependency_resolver.rb
new file mode 100644
index 0000000..56eadca
--- /dev/null
+++ b/lib/rubygems/dependency_resolver.rb
@@ -0,0 +1,254 @@
+require 'rubygems'
+require 'rubygems/dependency'
+require 'rubygems/exceptions'
+require 'rubygems/util/list'
+
+require 'uri'
+require 'net/http'
+
+##
+# Given a set of Gem::Dependency objects as +needed+ and a way to query the
+# set of available specs via +set+, calculates a set of ActivationRequest
+# objects which indicate all the specs that should be activated to meet the
+# all the requirements.
+
+class Gem::DependencyResolver
+
+  ##
+  # Contains all the conflicts encountered while doing resolution
+
+  attr_reader :conflicts
+
+  attr_accessor :development
+
+  attr_reader :missing
+
+  ##
+  # When a missing dependency, don't stop. Just go on and record what was
+  # missing.
+
+  attr_accessor :soft_missing
+
+  def self.compose_sets *sets
+    Gem::DependencyResolver::ComposedSet.new(*sets)
+  end
+
+  ##
+  # Provide a DependencyResolver that queries only against the already
+  # installed gems.
+
+  def self.for_current_gems needed
+    new needed, Gem::DependencyResolver::CurrentSet.new
+  end
+
+  ##
+  # Create DependencyResolver object which will resolve the tree starting
+  # with +needed+ Depedency objects.
+  #
+  # +set+ is an object that provides where to look for specifications to
+  # satisify the Dependencies. This defaults to IndexSet, which will query
+  # rubygems.org.
+
+  def initialize needed, set = nil
+    @set = set || Gem::DependencyResolver::IndexSet.new
+    @needed = needed
+
+    @conflicts    = nil
+    @development  = false
+    @missing      = []
+    @soft_missing = false
+  end
+
+  def requests s, act, reqs=nil
+    s.dependencies.reverse_each do |d|
+      next if d.type == :development and not @development
+      reqs = Gem::List.new Gem::DependencyResolver::DependencyRequest.new(d, act), reqs
+    end
+
+    @set.prefetch reqs
+
+    reqs
+  end
+
+  ##
+  # Proceed with resolution! Returns an array of ActivationRequest objects.
+
+  def resolve
+    @conflicts = []
+
+    needed = nil
+
+    @needed.reverse_each do |n|
+      request = Gem::DependencyResolver::DependencyRequest.new n, nil
+
+      needed = Gem::List.new request, needed
+    end
+
+    res = resolve_for needed, nil
+
+    raise Gem::DependencyResolutionError, res if
+      res.kind_of? Gem::DependencyResolver::DependencyConflict
+
+    res.to_a
+  end
+
+  ##
+  # The meat of the algorithm. Given +needed+ DependencyRequest objects and
+  # +specs+ being a list to ActivationRequest, calculate a new list of
+  # ActivationRequest objects.
+
+  def resolve_for needed, specs
+    while needed
+      dep = needed.value
+      needed = needed.tail
+
+      # If there is already a spec activated for the requested name...
+      if specs && existing = specs.find { |s| dep.name == s.name }
+
+        # then we're done since this new dep matches the
+        # existing spec.
+        next if dep.matches_spec? existing
+
+        # There is a conflict! We return the conflict
+        # object which will be seen by the caller and be
+        # handled at the right level.
+
+        # If the existing activation indicates that there
+        # are other possibles for it, then issue the conflict
+        # on the dep for the activation itself. Otherwise, issue
+        # it on the requester's request itself.
+        #
+        if existing.others_possible? or existing.request.requester.nil? then
+          conflict =
+            Gem::DependencyResolver::DependencyConflict.new dep, existing
+        else
+          depreq = existing.request.requester.request
+          conflict =
+            Gem::DependencyResolver::DependencyConflict.new depreq, existing, dep
+        end
+        @conflicts << conflict
+
+        return conflict
+      end
+
+      # Get a list of all specs that satisfy dep and platform
+      all_possible = @set.find_all dep
+      possible = select_local_platforms all_possible
+
+      case possible.size
+      when 0
+        @missing << dep
+
+        unless @soft_missing
+          # If there are none, then our work here is done.
+          raise Gem::UnsatisfiableDependencyError.new dep, all_possible
+        end
+      when 1
+        # If there is one, then we just add it to specs
+        # and process the specs dependencies by adding
+        # them to needed.
+
+        spec = possible.first
+        act = Gem::DependencyResolver::ActivationRequest.new spec, dep, false
+
+        specs = Gem::List.prepend specs, act
+
+        # Put the deps for at the beginning of needed
+        # rather than the end to match the depth first
+        # searching done by the multiple case code below.
+        #
+        # This keeps the error messages consistent.
+        needed = requests(spec, act, needed)
+      else
+        # There are multiple specs for this dep. This is
+        # the case that this class is built to handle.
+
+        # Sort them so that we try the highest versions
+        # first.
+        possible = possible.sort_by do |s|
+          [s.source, s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
+        end
+
+        # We track the conflicts seen so that we can report them
+        # to help the user figure out how to fix the situation.
+        conflicts = []
+
+        # To figure out which to pick, we keep resolving
+        # given each one being activated and if there isn't
+        # a conflict, we know we've found a full set.
+        #
+        # We use an until loop rather than #reverse_each
+        # to keep the stack short since we're using a recursive
+        # algorithm.
+        #
+        until possible.empty?
+          s = possible.pop
+
+          # Recursively call #resolve_for with this spec
+          # and add it's dependencies into the picture...
+
+          act = Gem::DependencyResolver::ActivationRequest.new s, dep
+
+          try = requests(s, act, needed)
+
+          res = resolve_for try, Gem::List.prepend(specs, act)
+
+          # While trying to resolve these dependencies, there may
+          # be a conflict!
+
+          if res.kind_of? Gem::DependencyResolver::DependencyConflict
+            # The conflict might be created not by this invocation
+            # but rather one up the stack, so if we can't attempt
+            # to resolve this conflict (conflict isn't with the spec +s+)
+            # then just return it so the caller can try to sort it out.
+            return res unless res.for_spec? s
+
+            # Otherwise, this is a conflict that we can attempt to fix
+            conflicts << [s, res]
+
+            # Optimization:
+            #
+            # Because the conflict indicates the dependency that trigger
+            # it, we can prune possible based on this new information.
+            #
+            # This cuts down on the number of iterations needed.
+            possible.delete_if { |x| !res.dependency.matches_spec? x }
+          else
+            # No conflict, return the specs
+            return res
+          end
+        end
+
+        # We tried all possibles and nothing worked, so we let the user
+        # know and include as much information about the problem since
+        # the user is going to have to take action to fix this.
+        raise Gem::ImpossibleDependenciesError.new(dep, conflicts)
+      end
+    end
+
+    specs
+  end
+
+  ##
+  # Returns the gems in +specs+ that match the local platform.
+
+  def select_local_platforms specs # :nodoc:
+    specs.select do |spec|
+      Gem::Platform.installable? spec
+    end
+  end
+
+end
+
+require 'rubygems/dependency_resolver/api_set'
+require 'rubygems/dependency_resolver/api_specification'
+require 'rubygems/dependency_resolver/activation_request'
+require 'rubygems/dependency_resolver/composed_set'
+require 'rubygems/dependency_resolver/current_set'
+require 'rubygems/dependency_resolver/dependency_conflict'
+require 'rubygems/dependency_resolver/dependency_request'
+require 'rubygems/dependency_resolver/index_set'
+require 'rubygems/dependency_resolver/index_specification'
+require 'rubygems/dependency_resolver/installed_specification'
+require 'rubygems/dependency_resolver/installer_set'
+
diff --git a/lib/rubygems/dependency_resolver/activation_request.rb b/lib/rubygems/dependency_resolver/activation_request.rb
new file mode 100644
index 0000000..25af637
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/activation_request.rb
@@ -0,0 +1,109 @@
+##
+# Specifies a Specification object that should be activated.
+# Also contains a dependency that was used to introduce this
+# activation.
+
+class Gem::DependencyResolver::ActivationRequest
+
+  attr_reader :request
+
+  attr_reader :spec
+
+  def initialize spec, req, others_possible = true
+    @spec = spec
+    @request = req
+    @others_possible = others_possible
+  end
+
+  def == other
+    case other
+    when Gem::Specification
+      @spec == other
+    when Gem::DependencyResolver::ActivationRequest
+      @spec == other.spec && @request == other.request
+    else
+      false
+    end
+  end
+
+  def download path
+    if @spec.respond_to? :source
+      source = @spec.source
+    else
+      source = Gem.sources.first
+    end
+
+    Gem.ensure_gem_subdirectories path
+
+    source.download full_spec, path
+  end
+
+  def full_name
+    @spec.full_name
+  end
+
+  def full_spec
+    Gem::Specification === @spec ? @spec : @spec.spec
+  end
+
+  def inspect # :nodoc:
+    others_possible = nil
+    others_possible = ' (others possible)' if @others_possible
+
+    '#<%s for %p from %s%s>' % [
+      self.class, @spec, @request, others_possible
+    ]
+  end
+
+  ##
+  # Indicates if the requested gem has already been installed.
+
+  def installed?
+    this_spec = full_spec
+
+    Gem::Specification.any? do |s|
+      s == this_spec
+    end
+  end
+
+  def name
+    @spec.name
+  end
+
+  ##
+  # Indicate if this activation is one of a set of possible
+  # requests for the same Dependency request.
+
+  def others_possible?
+    @others_possible
+  end
+
+  ##
+  # Return the ActivationRequest that contained the dependency
+  # that we were activated for.
+
+  def parent
+    @request.requester
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Activation request', ']' do
+      q.breakable
+      q.pp @spec
+
+      q.breakable
+      q.text ' for '
+      q.pp @request
+
+
+      q.breakable
+      q.text ' (other possible)' if @others_possible
+    end
+  end
+
+  def version
+    @spec.version
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/api_set.rb b/lib/rubygems/dependency_resolver/api_set.rb
new file mode 100644
index 0000000..469c005
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/api_set.rb
@@ -0,0 +1,65 @@
+##
+# The global rubygems pool, available via the rubygems.org API.
+# Returns instances of APISpecification.
+
+class Gem::DependencyResolver::APISet
+
+  def initialize
+    @data = Hash.new { |h,k| h[k] = [] }
+    @dep_uri = URI 'https://rubygems.org/api/v1/dependencies'
+  end
+
+  ##
+  # Return an array of APISpecification objects matching
+  # DependencyRequest +req+.
+
+  def find_all req
+    res = []
+
+    versions(req.name).each do |ver|
+      if req.dependency.match? req.name, ver[:number]
+        res << Gem::DependencyResolver::APISpecification.new(self, ver)
+      end
+    end
+
+    res
+  end
+
+  ##
+  # A hint run by the resolver to allow the Set to fetch
+  # data for DependencyRequests +reqs+.
+
+  def prefetch reqs
+    names = reqs.map { |r| r.dependency.name }
+    needed = names.find_all { |d| !@data.key?(d) }
+
+    return if needed.empty?
+
+    uri = @dep_uri + "?gems=#{needed.sort.join ','}"
+    str = Gem::RemoteFetcher.fetcher.fetch_path uri
+
+    Marshal.load(str).each do |ver|
+      @data[ver[:name]] << ver
+    end
+  end
+
+  ##
+  # Return data for all versions of the gem +name+.
+
+  def versions name
+    if @data.key?(name)
+      return @data[name]
+    end
+
+    uri = @dep_uri + "?gems=#{name}"
+    str = Gem::RemoteFetcher.fetcher.fetch_path uri
+
+    Marshal.load(str).each do |ver|
+      @data[ver[:name]] << ver
+    end
+
+    @data[name]
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/api_specification.rb b/lib/rubygems/dependency_resolver/api_specification.rb
new file mode 100644
index 0000000..ae68878
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/api_specification.rb
@@ -0,0 +1,39 @@
+##
+# Represents a specification retrieved via the rubygems.org
+# API. This is used to avoid having to load the full
+# Specification object when all we need is the name, version,
+# and dependencies.
+
+class Gem::DependencyResolver::APISpecification
+
+  attr_reader :dependencies
+  attr_reader :name
+  attr_reader :platform
+  attr_reader :set # :nodoc:
+  attr_reader :version
+
+  def initialize(set, api_data)
+    @set = set
+    @name = api_data[:name]
+    @version = Gem::Version.new api_data[:number]
+    @platform = api_data[:platform]
+    @dependencies = api_data[:dependencies].map do |name, ver|
+      Gem::Dependency.new name, ver.split(/\s*,\s*/)
+    end
+  end
+
+  def == other # :nodoc:
+    self.class === other and
+      @set          == other.set and
+      @name         == other.name and
+      @version      == other.version and
+      @platform     == other.platform and
+      @dependencies == other.dependencies
+  end
+
+  def full_name
+    "#{@name}-#{@version}"
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/composed_set.rb b/lib/rubygems/dependency_resolver/composed_set.rb
new file mode 100644
index 0000000..fb38128
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/composed_set.rb
@@ -0,0 +1,18 @@
+class Gem::DependencyResolver::ComposedSet
+
+  def initialize *sets
+    @sets = sets
+  end
+
+  def find_all req
+    res = []
+    @sets.each { |s| res += s.find_all(req) }
+    res
+  end
+
+  def prefetch reqs
+    @sets.each { |s| s.prefetch(reqs) }
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/current_set.rb b/lib/rubygems/dependency_resolver/current_set.rb
new file mode 100644
index 0000000..13bc490
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/current_set.rb
@@ -0,0 +1,16 @@
+##
+# A set which represents the installed gems. Respects
+# all the normal settings that control where to look
+# for installed gems.
+
+class Gem::DependencyResolver::CurrentSet
+
+  def find_all req
+    req.dependency.matching_specs
+  end
+
+  def prefetch gems
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/dependency_conflict.rb b/lib/rubygems/dependency_resolver/dependency_conflict.rb
new file mode 100644
index 0000000..1755d91
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/dependency_conflict.rb
@@ -0,0 +1,85 @@
+##
+# Used internally to indicate that a dependency conflicted
+# with a spec that would be activated.
+
+class Gem::DependencyResolver::DependencyConflict
+
+  attr_reader :activated
+
+  attr_reader :dependency
+
+  def initialize(dependency, activated, failed_dep=dependency)
+    @dependency = dependency
+    @activated = activated
+    @failed_dep = failed_dep
+  end
+
+  ##
+  # Return the 2 dependency objects that conflicted
+
+  def conflicting_dependencies
+    [@failed_dep.dependency, @activated.request.dependency]
+  end
+
+  ##
+  # Explanation of the conflict used by exceptions to print useful messages
+
+  def explanation
+    activated   = @activated.spec.full_name
+    requirement = @failed_dep.dependency.requirement
+
+    "  Activated %s instead of (%s) via:\n    %s\n" % [
+      activated, requirement, request_path.join(', ')
+    ]
+  end
+
+  def for_spec?(spec)
+    @dependency.name == spec.name
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Dependency conflict: ', ']' do
+      q.breakable
+
+      q.text 'activated '
+      q.pp @activated
+
+      q.breakable
+      q.text ' dependency '
+      q.pp @dependency
+
+      q.breakable
+      if @dependency == @failed_dep then
+        q.text ' failed'
+      else
+        q.text ' failed dependency '
+        q.pp @failed_dep
+      end
+    end
+  end
+
+  ##
+  # Path of specifications that requested this dependency
+
+  def request_path
+    current = requester
+    path    = []
+
+    while current do
+      path << current.spec.full_name
+
+      current = current.request.requester
+    end
+
+    path
+  end
+
+  ##
+  # Return the Specification that listed the dependency
+
+  def requester
+    @failed_dep.requester
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/dependency_request.rb b/lib/rubygems/dependency_resolver/dependency_request.rb
new file mode 100644
index 0000000..925691e
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/dependency_request.rb
@@ -0,0 +1,67 @@
+##
+# Used Internally. Wraps a Dependency object to also track which spec
+# contained the Dependency.
+
+class Gem::DependencyResolver::DependencyRequest
+
+  attr_reader :dependency
+
+  attr_reader :requester
+
+  def initialize(dep, act)
+    @dependency = dep
+    @requester = act
+  end
+
+  def ==(other)
+    case other
+    when Gem::Dependency
+      @dependency == other
+    when Gem::DependencyResolver::DependencyRequest
+      @dependency == other.dependency && @requester == other.requester
+    else
+      false
+    end
+  end
+
+  def matches_spec?(spec)
+    @dependency.matches_spec? spec
+  end
+
+  def name
+    @dependency.name
+  end
+
+  # Indicate that the request is for a gem explicitly requested by the user
+  def explicit?
+    @requester.nil?
+  end
+
+  # Indicate that the requset is for a gem requested as a dependency of another gem
+  def implicit?
+    !explicit?
+  end
+
+  # Return a String indicating who caused this request to be added (only
+  # valid for implicit requests)
+  def request_context
+    @requester ? @requester.request : "(unknown)"
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Dependency request ', ']' do
+      q.breakable
+      q.text @dependency.to_s
+
+      q.breakable
+      q.text ' requested by '
+      q.pp @requester
+    end
+  end
+
+  def to_s # :nodoc:
+    @dependency.to_s
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/index_set.rb b/lib/rubygems/dependency_resolver/index_set.rb
new file mode 100644
index 0000000..8c8bc43
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/index_set.rb
@@ -0,0 +1,64 @@
+##
+# The global rubygems pool represented via the traditional
+# source index.
+
+class Gem::DependencyResolver::IndexSet
+
+  def initialize
+    @f = Gem::SpecFetcher.fetcher
+
+    @all = Hash.new { |h,k| h[k] = [] }
+
+    list, = @f.available_specs :released
+
+    list.each do |uri, specs|
+      specs.each do |n|
+        @all[n.name] << [uri, n]
+      end
+    end
+
+    @specs = {}
+  end
+
+  ##
+  # Return an array of IndexSpecification objects matching
+  # DependencyRequest +req+.
+
+  def find_all req
+    res = []
+
+    name = req.dependency.name
+
+    @all[name].each do |uri, n|
+      if req.dependency.match? n then
+        res << Gem::DependencyResolver::IndexSpecification.new(
+          self, n.name, n.version, uri, n.platform)
+      end
+    end
+
+    res
+  end
+
+  ##
+  # Called from IndexSpecification to get a true Specification
+  # object.
+
+  def load_spec name, ver, platform, source
+    key = "#{name}-#{ver}-#{platform}"
+
+    @specs.fetch key do
+      tuple = Gem::NameTuple.new name, ver, platform
+
+      @specs[key] = source.fetch_spec tuple
+    end
+  end
+
+  ##
+  # No prefetching needed since we load the whole index in
+  # initially.
+
+  def prefetch gems
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/index_specification.rb b/lib/rubygems/dependency_resolver/index_specification.rb
new file mode 100644
index 0000000..7ffb32e
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/index_specification.rb
@@ -0,0 +1,60 @@
+##
+# Represents a possible Specification object returned
+# from IndexSet. Used to delay needed to download full
+# Specification objects when only the +name+ and +version+
+# are needed.
+
+class Gem::DependencyResolver::IndexSpecification
+
+  attr_reader :name
+
+  attr_reader :platform
+
+  attr_reader :source
+
+  attr_reader :version
+
+  def initialize set, name, version, source, platform
+    @set = set
+    @name = name
+    @version = version
+    @source = source
+    @platform = platform.to_s
+
+    @spec = nil
+  end
+
+  def dependencies
+    spec.dependencies
+  end
+
+  def full_name
+    "#{@name}-#{@version}"
+  end
+
+  def inspect # :nodoc:
+    '#<%s %s source %s>' % [self.class, full_name, @source]
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Index specification', ']' do
+      q.breakable
+      q.text full_name
+
+      unless Gem::Platform::RUBY == @platform then
+        q.breakable
+        q.text @platform.to_s
+      end
+
+      q.breakable
+      q.text 'source '
+      q.pp @source
+    end
+  end
+
+  def spec
+    @spec ||= @set.load_spec(@name, @version, @platform, @source)
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/installed_specification.rb b/lib/rubygems/dependency_resolver/installed_specification.rb
new file mode 100644
index 0000000..8595fcb
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/installed_specification.rb
@@ -0,0 +1,52 @@
+class Gem::DependencyResolver::InstalledSpecification
+
+  attr_reader :spec
+
+  def initialize set, spec, source=nil
+    @set    = set
+    @source = source
+    @spec   = spec
+  end
+
+  def == other # :nodoc:
+    self.class === other and
+      @set  == other.set and
+      @spec == other.spec
+  end
+
+  def dependencies
+    @spec.dependencies
+  end
+
+  def full_name
+    "#{@spec.name}-#{@spec.version}"
+  end
+
+  def name
+    @spec.name
+  end
+
+  def platform
+    @spec.platform
+  end
+
+  def installable_platform?
+    # BACKCOMPAT If the file is coming out of a specified file, then we
+    # ignore the platform. This code can be removed in RG 3.0.
+    if @source.kind_of? Gem::Source::SpecificFile
+      return true
+    else
+      Gem::Platform.match @spec.platform
+    end
+  end
+
+  def source
+    @source ||= Gem::Source::Installed.new
+  end
+
+  def version
+    @spec.version
+  end
+
+end
+
diff --git a/lib/rubygems/dependency_resolver/installer_set.rb b/lib/rubygems/dependency_resolver/installer_set.rb
new file mode 100644
index 0000000..e19fcd7
--- /dev/null
+++ b/lib/rubygems/dependency_resolver/installer_set.rb
@@ -0,0 +1,154 @@
+class Gem::DependencyResolver::InstallerSet
+
+  ##
+  # List of Gem::Specification objects that must always be installed.
+
+  attr_reader :always_install
+
+  ##
+  # Only install gems in the always_install list
+
+  attr_accessor :ignore_dependencies
+
+  ##
+  # Do not look in the installed set when finding specifications.  This is
+  # used by the --install-dir option to `gem install`
+
+  attr_accessor :ignore_installed
+
+  def initialize domain
+    @domain = domain
+
+    @f = Gem::SpecFetcher.fetcher
+
+    @all = Hash.new { |h,k| h[k] = [] }
+    @always_install      = []
+    @ignore_dependencies = false
+    @ignore_installed    = false
+    @loaded_remote_specs = []
+    @specs               = {}
+  end
+
+  ##
+  # Should local gems should be considered?
+
+  def consider_local?
+    @domain == :both or @domain == :local
+  end
+
+  ##
+  # Should remote gems should be considered?
+
+  def consider_remote?
+    @domain == :both or @domain == :remote
+  end
+
+  ##
+  # Returns an array of IndexSpecification objects matching DependencyRequest
+  # +req+.
+
+  def find_all req
+    res = []
+
+    dep  = req.dependency
+
+    return res if @ignore_dependencies and
+              @always_install.none? { |spec| dep.matches_spec? spec }
+
+    name = dep.name
+
+    dep.matching_specs.each do |gemspec|
+      next if @always_install.include? gemspec
+
+      res << Gem::DependencyResolver::InstalledSpecification.new(self, gemspec)
+    end unless @ignore_installed
+
+    if consider_local? then
+      local_source = Gem::Source::Local.new
+
+      if spec = local_source.find_gem(name, dep.requirement) then
+        res << Gem::DependencyResolver::IndexSpecification.new(
+          self, spec.name, spec.version, local_source, spec.platform)
+      end
+    end
+
+    if consider_remote? then
+      load_remote_specs dep
+
+      @all[name].each do |remote_source, n|
+        if dep.match? n then
+          res << Gem::DependencyResolver::IndexSpecification.new(
+            self, n.name, n.version, remote_source, n.platform)
+        end
+      end
+    end
+
+    res
+  end
+
+  def inspect # :nodoc:
+    always_install = @always_install.map { |s| s.full_name }
+
+    '#<%s domain: %s specs: %p always install: %p>' % [
+      self.class, @domain, @specs.keys, always_install,
+    ]
+  end
+
+  ##
+  # Loads remote prerelease specs if +dep+ is a prerelease dependency
+
+  def load_remote_specs dep
+    types = [:released]
+    types << :prerelease if dep.prerelease?
+
+    types.each do |type|
+      next if @loaded_remote_specs.include? type
+      @loaded_remote_specs << type
+
+      list, = @f.available_specs type
+
+      list.each do |uri, specs|
+        specs.each do |n|
+          @all[n.name] << [uri, n]
+        end
+      end
+    end
+  end
+
+  ##
+  # Called from IndexSpecification to get a true Specification
+  # object.
+
+  def load_spec name, ver, platform, source
+    key = "#{name}-#{ver}-#{platform}"
+
+    @specs.fetch key do
+      tuple = Gem::NameTuple.new name, ver, platform
+
+      @specs[key] = source.fetch_spec tuple
+    end
+  end
+
+  ##
+  # No prefetching needed since we load the whole index in initially.
+
+  def prefetch(reqs)
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[InstallerSet', ']' do
+      q.breakable
+      q.text "domain: #{@domain}"
+
+      q.breakable
+      q.text 'specs: '
+      q.pp @specs.keys
+
+      q.breakable
+      q.text 'always install: '
+      q.pp @always_install
+    end
+  end
+
+end
+
diff --git a/lib/rubygems/deprecate.rb b/lib/rubygems/deprecate.rb
index e19360d..274d6a5 100644
--- a/lib/rubygems/deprecate.rb
+++ b/lib/rubygems/deprecate.rb
@@ -50,7 +50,7 @@ module Gem::Deprecate
     class_eval {
       old = "_deprecated_#{name}"
       alias_method old, name
-      define_method name do |*args, &block|
+      define_method name do |*args, &block| # TODO: really works on 1.8.7?
         klass = self.kind_of? Module
         target = klass ? "#{self}." : "#{self.class}#"
         msg = [ "NOTE: #{target}#{name} is deprecated",
diff --git a/lib/rubygems/doctor.rb b/lib/rubygems/doctor.rb
index 0aa0f7b..4fb399e 100644
--- a/lib/rubygems/doctor.rb
+++ b/lib/rubygems/doctor.rb
@@ -1,5 +1,6 @@
 require 'rubygems'
 require 'rubygems/user_interaction'
+require 'pathname'
 
 ##
 # Cleans up after a partially-failed uninstall or for an invalid
@@ -23,17 +24,13 @@ class Gem::Doctor
     ['build_info',     '.info'],
     ['cache',          '.gem'],
     ['doc',            ''],
-    ['extensions',     ''],
     ['gems',           ''],
   ]
 
-  missing =
-    Gem::REPOSITORY_SUBDIRECTORIES.sort -
+  raise 'Update REPOSITORY_EXTENSION_MAP' unless
+    Gem::REPOSITORY_SUBDIRECTORIES.sort ==
       REPOSITORY_EXTENSION_MAP.map { |(k,_)| k }.sort
 
-  raise "Update REPOSITORY_EXTENSION_MAP, missing: #{missing.join ', '}" unless
-    missing.empty?
-
   ##
   # Creates a new Gem::Doctor that will clean up +gem_repository+.  Only one
   # gem repository may be cleaned at a time.
@@ -41,7 +38,7 @@ class Gem::Doctor
   # If +dry_run+ is true no files or directories will be removed.
 
   def initialize gem_repository, dry_run = false
-    @gem_repository = gem_repository
+    @gem_repository = Pathname(gem_repository)
     @dry_run        = dry_run
 
     @installed_specs = nil
@@ -99,29 +96,26 @@ class Gem::Doctor
   # Removes files in +sub_directory+ with +extension+
 
   def doctor_child sub_directory, extension # :nodoc:
-    directory = File.join(@gem_repository, sub_directory)
-
-    Dir.entries(directory).sort.each do |ent|
-      next if ent == "." || ent == ".."
+    directory = @gem_repository + sub_directory
 
-      child = File.join(directory, ent)
-      next unless File.exists?(child)
+    directory.children.sort.each do |child|
+      next unless child.exist?
 
-      basename = File.basename(child, extension)
+      basename = child.basename(extension).to_s
       next if installed_specs.include? basename
       next if /^rubygems-\d/ =~ basename
       next if 'specifications' == sub_directory and 'default' == basename
 
-      type = File.directory?(child) ? 'directory' : 'file'
+      type = child.directory? ? 'directory' : 'file'
 
       action = if @dry_run then
                  'Extra'
                else
-                 FileUtils.rm_r(child)
+                 child.rmtree
                  'Removed'
                end
 
-      say "#{action} #{type} #{sub_directory}/#{File.basename(child)}"
+      say "#{action} #{type} #{sub_directory}/#{child.basename}"
     end
   rescue Errno::ENOENT
     # ignore
diff --git a/lib/rubygems/errors.rb b/lib/rubygems/errors.rb
index fc9bfbc..4a92011 100644
--- a/lib/rubygems/errors.rb
+++ b/lib/rubygems/errors.rb
@@ -19,6 +19,8 @@ module Gem
     attr_accessor :requirement
   end
 
+  # FIX: does this need to exist? The subclass is the only other reference
+  # I can find.
   class ErrorReason; end
 
   # Generated when trying to lookup a gem to indicate that the gem
@@ -73,27 +75,12 @@ module Gem
   # data from a source
 
   class SourceFetchProblem < ErrorReason
-
-    ##
-    # Creates a new SourceFetchProblem for the given +source+ and +error+.
-
     def initialize(source, error)
       @source = source
       @error = error
     end
 
-    ##
-    # The source that had the fetch problem.
-
-    attr_reader :source
-
-    ##
-    # The fetch error which is an Exception subclass.
-
-    attr_reader :error
-
-    ##
-    # An English description of the error.
+    attr_reader :source, :error
 
     def wordy
       "Unable to download data from #{@source.uri} - #{@error.message}"
diff --git a/lib/rubygems/exceptions.rb b/lib/rubygems/exceptions.rb
index 6bd50ec..eb5db6e 100644
--- a/lib/rubygems/exceptions.rb
+++ b/lib/rubygems/exceptions.rb
@@ -23,7 +23,7 @@ class Gem::DependencyError < Gem::Exception; end
 class Gem::DependencyRemovalException < Gem::Exception; end
 
 ##
-# Raised by Gem::Resolver when a Gem::Dependency::Conflict reaches the
+# Raised by Gem::DependencyResolver when a Gem::DependencyConflict reaches the
 # toplevel.  Indicates which dependencies were incompatible through #conflict
 # and #conflicting_dependencies
 
@@ -35,7 +35,7 @@ class Gem::DependencyResolutionError < Gem::Exception
     @conflict = conflict
     a, b = conflicting_dependencies
 
-    super "conflicting dependencies #{a} and #{b}\n#{@conflict.explanation}"
+    super "unable to resolve conflicting dependencies '#{a}' and '#{b}'"
   end
 
   def conflicting_dependencies
@@ -81,16 +81,7 @@ end
 
 class Gem::GemNotFoundException < Gem::Exception; end
 
-##
-# Raised by the DependencyInstaller when a specific gem cannot be found
-
 class Gem::SpecificGemNotFoundException < Gem::GemNotFoundException
-
-  ##
-  # Creates a new SpecificGemNotFoundException for a gem with the given +name+
-  # and +version+.  Any +errors+ encountered when attempting to find the gem
-  # are also stored.
-
   def initialize(name, version, errors=nil)
     super "Could not find a valid gem '#{name}' (#{version}) locally or in a repository"
 
@@ -99,25 +90,11 @@ class Gem::SpecificGemNotFoundException < Gem::GemNotFoundException
     @errors = errors
   end
 
-  ##
-  # The name of the gem that could not be found.
-
-  attr_reader :name
-
-  ##
-  # The version of the gem that could not be found.
-
-  attr_reader :version
-
-  ##
-  # Errors encountered attempting to find the gem.
-
-  attr_reader :errors
-
+  attr_reader :name, :version, :errors
 end
 
 ##
-# Raised by Gem::Resolver when dependencies conflict and create the
+# Raised by Gem::DependencyResolver when dependencies conflict and create the
 # inability to find a valid possible spec for a request.
 
 class Gem::ImpossibleDependenciesError < Gem::Exception
@@ -177,15 +154,6 @@ class Gem::RemoteInstallationSkipped < Gem::Exception; end
 # Represents an error communicating via HTTP.
 class Gem::RemoteSourceException < Gem::Exception; end
 
-##
-# Raised when a gem dependencies file specifies a ruby version that does not
-# match the current version.
-
-class Gem::RubyVersionMismatch < Gem::Exception; end
-
-##
-# Raised by Gem::Validator when something is not right in a gem.
-
 class Gem::VerificationError < Gem::Exception; end
 
 ##
@@ -193,15 +161,8 @@ class Gem::VerificationError < Gem::Exception; end
 # exit_code
 
 class Gem::SystemExitException < SystemExit
-
-  ##
-  # The exit code for the process
-
   attr_accessor :exit_code
 
-  ##
-  # Creates a new SystemExitException with the given +exit_code+
-
   def initialize(exit_code)
     @exit_code = exit_code
 
@@ -211,21 +172,13 @@ class Gem::SystemExitException < SystemExit
 end
 
 ##
-# Raised by Resolver when a dependency requests a gem for which
+# Raised by DependencyResolver when a dependency requests a gem for which
 # there is no spec.
 
 class Gem::UnsatisfiableDependencyError < Gem::Exception
 
-  ##
-  # The unsatisfiable dependency.  This is a
-  # Gem::Resolver::DependencyRequest, not a Gem::Dependency
-
   attr_reader :dependency
 
-  ##
-  # Creates a new UnsatisfiableDependencyError for the unsatisfiable
-  # Gem::Resolver::DependencyRequest +dep+
-
   def initialize dep, platform_mismatch=nil
     if platform_mismatch and !platform_mismatch.empty?
       plats = platform_mismatch.map { |x| x.platform.to_s }.sort.uniq
diff --git a/lib/rubygems/ext.rb b/lib/rubygems/ext.rb
index 5af6bbf..b2bb09a 100644
--- a/lib/rubygems/ext.rb
+++ b/lib/rubygems/ext.rb
@@ -4,12 +4,13 @@
 # See LICENSE.txt for permissions.
 #++
 
+require 'rubygems'
+
 ##
 # Classes for building C extensions live here.
 
 module Gem::Ext; end
 
-require 'rubygems/ext/build_error'
 require 'rubygems/ext/builder'
 require 'rubygems/ext/configure_builder'
 require 'rubygems/ext/ext_conf_builder'
diff --git a/lib/rubygems/ext/build_error.rb b/lib/rubygems/ext/build_error.rb
deleted file mode 100644
index bfe85ff..0000000
--- a/lib/rubygems/ext/build_error.rb
+++ /dev/null
@@ -1,6 +0,0 @@
-##
-# Raised when there is an error while building extensions.
-
-class Gem::Ext::BuildError < Gem::InstallError
-end
-
diff --git a/lib/rubygems/ext/builder.rb b/lib/rubygems/ext/builder.rb
index cbae823..8c05723 100644
--- a/lib/rubygems/ext/builder.rb
+++ b/lib/rubygems/ext/builder.rb
@@ -28,7 +28,7 @@ class Gem::Ext::Builder
 
   def self.make(dest_path, results)
     unless File.exist? 'Makefile' then
-      raise Gem::InstallError, 'Makefile not found'
+      raise Gem::InstallError, "Makefile not found:\n\n#{results.join "\n"}"
     end
 
     # try to find make program from Ruby configure arguments first
@@ -40,18 +40,14 @@ class Gem::Ext::Builder
 
     destdir = '"DESTDIR=%s"' % ENV['DESTDIR'] if RUBY_VERSION > '2.0'
 
-    ['clean', '', 'install'].each do |target|
+    ['', 'install'].each do |target|
       # Pass DESTDIR via command line to override what's in MAKEFLAGS
       cmd = [
         make_program,
         destdir,
         target
       ].join(' ').rstrip
-      begin
-        run(cmd, results, "make #{target}".rstrip)
-      rescue Gem::InstallError
-        raise unless target == 'clean' # ignore clean failure
-      end
+      run(cmd, results, "make #{target}".rstrip)
     end
   end
 
@@ -78,27 +74,18 @@ class Gem::Ext::Builder
 
     unless $?.success? then
       results << "Building has failed. See above output for more information on the failure." if verbose
-
-      exit_reason =
-        if $?.exited? then
-          ", exit code #{$?.exitstatus}"
-        elsif $?.signaled? then
-          ", uncaught signal #{$?.termsig}"
-        end
-
-      raise Gem::InstallError, "#{command_name || class_name} failed#{exit_reason}"
+      raise Gem::InstallError, "#{command_name || class_name} failed:\n\n#{results.join "\n"}"
     end
   end
 
   ##
-  # Creates a new extension builder for +spec+.  If the +spec+ does not yet
-  # have build arguments, saved, set +build_args+ which is an ARGV-style
-  # array.
+  # Creates a new extension builder for +spec+ using the given +build_args+.
+  # The gem for +spec+ is unpacked in +gem_dir+.
 
-  def initialize spec, build_args = spec.build_args
+  def initialize spec, build_args
     @spec       = spec
     @build_args = build_args
-    @gem_dir    = spec.full_gem_path
+    @gem_dir    = spec.gem_dir
 
     @ran_rake   = nil
   end
@@ -126,10 +113,12 @@ class Gem::Ext::Builder
   end
 
   ##
-  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.
+  # Logs the build +output+ in +build_dir+, then raises ExtensionBuildError.
 
   def build_error build_dir, output, backtrace = nil # :nodoc:
-    gem_make_out = write_gem_make_out output
+    gem_make_out = File.join build_dir, 'gem_make.out'
+
+    open gem_make_out, 'wb' do |io| io.puts output end
 
     message = <<-EOF
 ERROR: Failed to build gem native extension.
@@ -140,16 +129,14 @@ Gem files will remain installed in #{@gem_dir} for inspection.
 Results logged to #{gem_make_out}
 EOF
 
-    raise Gem::Ext::BuildError, message, backtrace
+    raise Gem::Installer::ExtensionBuildError, message, backtrace
   end
 
   def build_extension extension, dest_path # :nodoc:
     results = []
 
     extension ||= '' # I wish I knew why this line existed
-    extension_dir =
-      File.expand_path File.join @gem_dir, File.dirname(extension)
-    lib_dir = File.join @spec.full_gem_path, @spec.raw_require_paths.first
+    extension_dir = File.join @gem_dir, File.dirname(extension)
 
     builder = builder_for extension
 
@@ -159,15 +146,12 @@ EOF
       CHDIR_MUTEX.synchronize do
         Dir.chdir extension_dir do
           results = builder.build(extension, @gem_dir, dest_path,
-                                  results, @build_args, lib_dir)
+                                  results, @build_args)
 
           say results.join("\n") if Gem.configuration.really_verbose
         end
       end
-
-      write_gem_make_out results.join "\n"
-    rescue => e
-      results << e.message
+    rescue
       build_error extension_dir, results.join("\n"), $@
     end
   end
@@ -186,9 +170,7 @@ EOF
       say "This could take a while..."
     end
 
-    dest_path = @spec.extension_dir
-
-    FileUtils.rm_f @spec.gem_build_complete_path
+    dest_path = File.join @gem_dir, @spec.require_paths.first
 
     @ran_rake = false # only run rake once
 
@@ -197,21 +179,6 @@ EOF
 
       build_extension extension, dest_path
     end
-
-    FileUtils.touch @spec.gem_build_complete_path
-  end
-
-  ##
-  # Writes +output+ to gem_make.out in the extension install directory.
-
-  def write_gem_make_out output # :nodoc:
-    destination = File.join @spec.extension_dir, 'gem_make.out'
-
-    FileUtils.mkdir_p @spec.extension_dir
-
-    open destination, 'wb' do |io| io.puts output end
-
-    destination
   end
 
 end
diff --git a/lib/rubygems/ext/cmake_builder.rb b/lib/rubygems/ext/cmake_builder.rb
index 24531bc..17bd6c2 100644
--- a/lib/rubygems/ext/cmake_builder.rb
+++ b/lib/rubygems/ext/cmake_builder.rb
@@ -1,7 +1,7 @@
 require 'rubygems/command'
 
 class Gem::Ext::CmakeBuilder < Gem::Ext::Builder
-  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
+  def self.build(extension, directory, dest_path, results)
     unless File.exist?('Makefile') then
       cmd = "cmake . -DCMAKE_INSTALL_PREFIX=#{dest_path}"
       cmd << " #{Gem::Command.build_args.join ' '}" unless Gem::Command.build_args.empty?
diff --git a/lib/rubygems/ext/configure_builder.rb b/lib/rubygems/ext/configure_builder.rb
index f66e393..ef8b29e 100644
--- a/lib/rubygems/ext/configure_builder.rb
+++ b/lib/rubygems/ext/configure_builder.rb
@@ -4,9 +4,11 @@
 # See LICENSE.txt for permissions.
 #++
 
+require 'rubygems/ext/builder'
+
 class Gem::Ext::ConfigureBuilder < Gem::Ext::Builder
 
-  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
+  def self.build(extension, directory, dest_path, results, args=[])
     unless File.exist?('Makefile') then
       cmd = "sh ./configure --prefix=#{dest_path}"
       cmd << " #{args.join ' '}" unless args.empty?
diff --git a/lib/rubygems/ext/ext_conf_builder.rb b/lib/rubygems/ext/ext_conf_builder.rb
index 990fd18..5112eb8 100644
--- a/lib/rubygems/ext/ext_conf_builder.rb
+++ b/lib/rubygems/ext/ext_conf_builder.rb
@@ -4,13 +4,15 @@
 # See LICENSE.txt for permissions.
 #++
 
+require 'rubygems/ext/builder'
+require 'rubygems/command'
 require 'fileutils'
 require 'tempfile'
 
 class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
   FileEntry = FileUtils::Entry_ # :nodoc:
 
-  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
+  def self.build(extension, directory, dest_path, results, args=[])
     tmp_dest = Dir.mktmpdir(".gem.", ".")
 
     t = nil
@@ -34,11 +36,7 @@ class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
         ENV["RUBYOPT"] = ["-r#{siteconf_path}", rubyopt].compact.join(' ')
         cmd = [Gem.ruby, File.basename(extension), *args].join ' '
 
-        begin
-          run cmd, results
-        ensure
-          FileUtils.mv 'mkmf.log', dest_path if File.exist? 'mkmf.log'
-        end
+        run cmd, results
 
         ENV["DESTDIR"] = nil
         ENV["RUBYOPT"] = rubyopt
@@ -47,14 +45,6 @@ class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
         make dest_path, results
 
         if tmp_dest
-          # TODO remove in RubyGems 3
-          if Gem.install_extension_in_lib and lib_dir then
-            FileUtils.mkdir_p lib_dir
-            entries = Dir.entries(tmp_dest) - %w[. ..]
-            entries = entries.map { |entry| File.join tmp_dest, entry }
-            FileUtils.cp_r entries, lib_dir
-          end
-
           FileEntry.new(tmp_dest).traverse do |ent|
             destent = ent.class.new(dest_path, ent.rel)
             destent.exist? or File.rename(ent.path, destent.path)
diff --git a/lib/rubygems/ext/rake_builder.rb b/lib/rubygems/ext/rake_builder.rb
index d5ebf59..2ac6edd 100644
--- a/lib/rubygems/ext/rake_builder.rb
+++ b/lib/rubygems/ext/rake_builder.rb
@@ -4,9 +4,12 @@
 # See LICENSE.txt for permissions.
 #++
 
+require 'rubygems/ext/builder'
+require 'rubygems/command'
+
 class Gem::Ext::RakeBuilder < Gem::Ext::Builder
 
-  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
+  def self.build(extension, directory, dest_path, results, args=[])
     if File.basename(extension) =~ /mkrf_conf/i then
       cmd = "#{Gem.ruby} #{File.basename extension}"
       cmd << " #{args.join " "}" unless args.empty?
@@ -19,7 +22,7 @@ class Gem::Ext::RakeBuilder < Gem::Ext::Builder
     rake = ENV['rake']
 
     rake ||= begin
-               "#{Gem.ruby} -rubygems #{Gem.bin_path('rake', 'rake')}"
+               "\"#{Gem.ruby}\" -rubygems #{Gem.bin_path('rake', 'rake')}"
              rescue Gem::Exception
              end
 
diff --git a/lib/rubygems/gemcutter_utilities.rb b/lib/rubygems/gemcutter_utilities.rb
index 6a4da9e..9dbc18b 100644
--- a/lib/rubygems/gemcutter_utilities.rb
+++ b/lib/rubygems/gemcutter_utilities.rb
@@ -56,10 +56,8 @@ module Gem::GemcutterUtilities
 
   ##
   # Creates an RubyGems API to +host+ and +path+ with the given HTTP +method+.
-  #
-  # If +allowed_push_host+ metadata is present, then it will only allow that host.
 
-  def rubygems_api_request(method, path, host = nil, allowed_push_host = nil, &block)
+  def rubygems_api_request(method, path, host = nil, &block)
     require 'net/http'
 
     self.host = host if host
@@ -68,11 +66,6 @@ module Gem::GemcutterUtilities
       terminate_interaction 1 # TODO: question this
     end
 
-    if allowed_push_host and self.host != allowed_push_host
-      alert_error "#{self.host.inspect} is not allowed by the gemspec, which only allows #{allowed_push_host.inspect}"
-      terminate_interaction 1
-    end
-
     uri = URI.parse "#{self.host}/#{path}"
 
     request_method = Net::HTTP.const_get method.to_s.capitalize
diff --git a/lib/rubygems/installer.rb b/lib/rubygems/installer.rb
index c809816..ac3113f 100644
--- a/lib/rubygems/installer.rb
+++ b/lib/rubygems/installer.rb
@@ -33,9 +33,9 @@ class Gem::Installer
   ENV_PATHS = %w[/usr/bin/env /bin/env]
 
   ##
-  # Deprecated in favor of Gem::Ext::BuildError
-
-  ExtensionBuildError = Gem::Ext::BuildError # :nodoc:
+  # Raised when there is an error while building extensions.
+  #
+  class ExtensionBuildError < Gem::InstallError; end
 
   include Gem::UserInteraction
 
@@ -57,11 +57,6 @@ class Gem::Installer
 
   attr_reader :options
 
-  ##
-  # Sets the specification for .gem-less installs.
-
-  attr_writer :spec
-
   @path_warning = false
 
   class << self
@@ -212,8 +207,6 @@ class Gem::Installer
   def install
     pre_install_checks
 
-    FileUtils.rm_f File.join gem_home, 'specifications', @spec.spec_name
-
     run_pre_install_hooks
 
     # Completely remove any previous gem files
@@ -353,10 +346,7 @@ class Gem::Installer
 
   def write_spec
     open spec_file, 'w' do |file|
-      spec.installed_by_version = Gem.rubygems_version
-
       file.puts spec.to_ruby_for_cache
-
       file.fsync rescue nil # for filesystems without fsync(2)
     end
   end
@@ -480,7 +470,7 @@ class Gem::Installer
   #
 
   def shebang(bin_file_name)
-    ruby_name = RbConfig::CONFIG['ruby_install_name'] if @env_shebang
+    ruby_name = Gem::ConfigMap[:ruby_install_name] if @env_shebang
     path = File.join gem_dir, spec.bindir, bin_file_name
     first_line = File.open(path, "rb") {|file| file.gets}
 
@@ -493,7 +483,7 @@ class Gem::Installer
 
     if which = Gem.configuration[:custom_shebang]
       # replace bin_file_name with "ruby" to avoid endless loops
-      which = which.gsub(/ #{bin_file_name}$/," #{RbConfig::CONFIG['ruby_install_name']}")
+      which = which.gsub(/ #{bin_file_name}$/," #{Gem::ConfigMap[:ruby_install_name]}")
 
       which = which.gsub(/\$(\w+)/) do
         case $1
@@ -641,7 +631,7 @@ version = "#{Gem::Requirement.default}"
 if ARGV.first
   str = ARGV.first
   str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
-  if str =~ /\\A_(.*)_\\z/ and Gem::Version.correct?($1) then
+  if str =~ /\\A_(.*)_\\z/
     version = $1
     ARGV.shift
   end
@@ -678,7 +668,7 @@ TEXT
   end
 
   ##
-  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.
+  # Logs the build +output+ in +build_dir+, then raises ExtensionBuildError.
   #
   # TODO:  Delete this for RubyGems 3.  It remains for API compatibility
 
diff --git a/lib/rubygems/installer_test_case.rb b/lib/rubygems/installer_test_case.rb
index d03e512..62a468a 100644
--- a/lib/rubygems/installer_test_case.rb
+++ b/lib/rubygems/installer_test_case.rb
@@ -56,6 +56,11 @@ class Gem::Installer
   ##
   # Available through requiring rubygems/installer_test_case
 
+  attr_writer :spec
+
+  ##
+  # Available through requiring rubygems/installer_test_case
+
   attr_writer :wrappers
 end
 
diff --git a/lib/rubygems/package.rb b/lib/rubygems/package.rb
index 0ed6e1b..c4a77cb 100644
--- a/lib/rubygems/package.rb
+++ b/lib/rubygems/package.rb
@@ -345,20 +345,11 @@ EOM
 
         FileUtils.rm_rf destination
 
-        mkdir_options = {}
-        mkdir_options[:mode] = entry.header.mode if entry.directory?
-        mkdir =
-          if entry.directory? then
-            destination
-          else
-            File.dirname destination
-          end
-
-        FileUtils.mkdir_p mkdir, mkdir_options
+        FileUtils.mkdir_p File.dirname destination
 
         open destination, 'wb', entry.header.mode do |out|
           out.write entry.read
-        end if entry.file?
+        end
 
         say destination if Gem.configuration.really_verbose
       end
diff --git a/lib/rubygems/package/tar_header.rb b/lib/rubygems/package/tar_header.rb
index f9ab13a..28da1db 100644
--- a/lib/rubygems/package/tar_header.rb
+++ b/lib/rubygems/package/tar_header.rb
@@ -134,7 +134,7 @@ class Gem::Package::TarHeader
     vals[:gid] ||= 0
     vals[:mtime] ||= 0
     vals[:checksum] ||= ""
-    vals[:typeflag] = "0" if vals[:typeflag].nil? || vals[:typeflag].empty?
+    vals[:typeflag] ||= "0"
     vals[:magic] ||= "ustar"
     vals[:version] ||= "00"
     vals[:uname] ||= "wheel"
diff --git a/lib/rubygems/platform.rb b/lib/rubygems/platform.rb
index 1bcd754..e050959 100644
--- a/lib/rubygems/platform.rb
+++ b/lib/rubygems/platform.rb
@@ -16,7 +16,7 @@ class Gem::Platform
   attr_accessor :version
 
   def self.local
-    arch = RbConfig::CONFIG['arch']
+    arch = Gem::ConfigMap[:arch]
     arch = "#{arch}_60" if arch =~ /mswin32$/
     @local ||= new(arch)
   end
diff --git a/lib/rubygems/psych_additions.rb b/lib/rubygems/psych_additions.rb
index 0e4ebbd..dcc13fd 100644
--- a/lib/rubygems/psych_additions.rb
+++ b/lib/rubygems/psych_additions.rb
@@ -4,6 +4,6 @@
 # blows up.
 
 module Psych # :nodoc:
-  class PrivateType # :nodoc:
+  class PrivateType
   end
 end
diff --git a/lib/rubygems/rdoc.rb b/lib/rubygems/rdoc.rb
index 633bd89..f16c869 100644
--- a/lib/rubygems/rdoc.rb
+++ b/lib/rubygems/rdoc.rb
@@ -8,7 +8,7 @@ rescue Gem::LoadError
   # swallow
 else
   # This will force any deps that 'rdoc' might have
-  # (such as json) that are ambiguous to be activated, which
+  # (such as json) that are ambigious to be activated, which
   # is important because we end up using Specification.reset
   # and we don't want the warning it pops out.
   Gem.finish_resolve
@@ -193,7 +193,7 @@ class Gem::RDoc # :nodoc: all
     ::RDoc::Parser::C.reset
 
     args = @spec.rdoc_options
-    args.concat @spec.source_paths
+    args.concat @spec.require_paths
     args.concat @spec.extra_rdoc_files
 
     case config_args = Gem.configuration[:rdoc]
diff --git a/lib/rubygems/remote_fetcher.rb b/lib/rubygems/remote_fetcher.rb
index 58991ca..6abd6bd 100644
--- a/lib/rubygems/remote_fetcher.rb
+++ b/lib/rubygems/remote_fetcher.rb
@@ -78,6 +78,7 @@ class Gem::RemoteFetcher
   end
 
   ##
+  #
   # Given a source at +uri+, calculate what hostname to actually
   # connect to query the data for it.
 
@@ -90,7 +91,7 @@ class Gem::RemoteFetcher
     rescue Resolv::ResolvError
       uri
     else
-      URI.parse "#{uri.scheme}://#{res.target}#{uri.path}"
+      URI.parse "#{res.target}#{uri.path}"
     end
   end
 
@@ -106,7 +107,7 @@ class Gem::RemoteFetcher
 
     return if found.empty?
 
-    spec, source = found.max_by { |(s,_)| s.version }
+    spec, source = found.sort_by { |(s,_)| s.version }.last
 
     download spec, source.uri.to_s
   end
@@ -131,19 +132,11 @@ class Gem::RemoteFetcher
 
     FileUtils.mkdir_p cache_dir rescue nil unless File.exist? cache_dir
 
-    # Always escape URI's to deal with potential spaces and such
-    # It should also be considered that source_uri may already be
-    # a valid URI with escaped characters. e.g. "{DESede}" is encoded
-    # as "%7BDESede%7D". If this is escaped again the percentage
-    # symbols will be escaped.
-    unless source_uri.is_a?(URI::Generic)
-      begin
-        source_uri = URI.parse(source_uri)
-      rescue
-        source_uri = URI.parse(URI.const_defined?(:DEFAULT_PARSER) ?
-                               URI::DEFAULT_PARSER.escape(source_uri.to_s) :
-                               URI.escape(source_uri.to_s))
-      end
+   # Always escape URI's to deal with potential spaces and such
+    unless URI::Generic === source_uri
+      source_uri = URI.parse(URI.const_defined?(:DEFAULT_PARSER) ?
+                             URI::DEFAULT_PARSER.escape(source_uri.to_s) :
+                             URI.escape(source_uri.to_s))
     end
 
     scheme = source_uri.scheme
@@ -293,20 +286,19 @@ class Gem::RemoteFetcher
   def cache_update_path uri, path = nil, update = true
     mtime = path && File.stat(path).mtime rescue nil
 
-    data = fetch_path(uri, mtime)
-
-    if data == nil # indicates the server returned 304 Not Modified
-      return Gem.read_binary(path)
-    end
+    if mtime && Net::HTTPNotModified === fetch_path(uri, mtime, true)
+      Gem.read_binary(path)
+    else
+      data = fetch_path(uri)
 
-    if update and path
-      open(path, 'wb') do |io|
-        io.flock(File::LOCK_EX)
-        io.write data
+      if update and path then
+        open(path, 'wb') do |io|
+          io.write data
+        end
       end
-    end
 
-    data
+      data
+    end
   end
 
   ##
diff --git a/lib/rubygems/request.rb b/lib/rubygems/request.rb
index d2f076f..fe72611 100644
--- a/lib/rubygems/request.rb
+++ b/lib/rubygems/request.rb
@@ -21,7 +21,7 @@ class Gem::Request
     @proxy_uri =
       case proxy
       when :no_proxy then nil
-      when nil       then get_proxy_from_env uri.scheme
+      when nil then get_proxy_from_env
       when URI::HTTP then proxy
       else URI.parse(proxy)
       end
@@ -48,14 +48,15 @@ class Gem::Request
       connection.key = OpenSSL::PKey::RSA.new pem
     end
 
-    store.set_default_paths
-    add_rubygems_trusted_certs(store)
     if Gem.configuration.ssl_ca_cert
       if File.directory? Gem.configuration.ssl_ca_cert
         store.add_path Gem.configuration.ssl_ca_cert
       else
         store.add_file Gem.configuration.ssl_ca_cert
       end
+    else
+      store.set_default_paths
+      add_rubygems_trusted_certs(store)
     end
     connection.cert_store = store
   rescue LoadError => e
@@ -105,8 +106,7 @@ class Gem::Request
     request = @request_class.new @uri.request_uri
 
     unless @uri.nil? || @uri.user.nil? || @uri.user.empty? then
-      request.basic_auth Gem::UriFormatter.new(@uri.user).unescape,
-                         Gem::UriFormatter.new(@uri.password).unescape
+      request.basic_auth @uri.user, @uri.password
     end
 
     request.add_field 'User-Agent', @user_agent
@@ -202,27 +202,19 @@ class Gem::Request
   end
 
   ##
-  # Returns a proxy URI for the given +scheme+ if one is set in the
-  # environment variables.
+  # Returns an HTTP proxy URI if one is set in the environment variables.
 
-  def get_proxy_from_env scheme = 'http'
-    _scheme = scheme.downcase
-    _SCHEME = scheme.upcase
-    env_proxy = ENV["#{_scheme}_proxy"] || ENV["#{_SCHEME}_PROXY"]
+  def get_proxy_from_env
+    env_proxy = ENV['http_proxy'] || ENV['HTTP_PROXY']
 
-    no_env_proxy = env_proxy.nil? || env_proxy.empty?
-
-    return get_proxy_from_env 'http' if no_env_proxy and _scheme != 'http'
-    return nil                       if no_env_proxy
+    return nil if env_proxy.nil? or env_proxy.empty?
 
     uri = URI(Gem::UriFormatter.new(env_proxy).normalize)
 
     if uri and uri.user.nil? and uri.password.nil? then
-      user     = ENV["#{_scheme}_proxy_user"] || ENV["#{_SCHEME}_PROXY_USER"]
-      password = ENV["#{_scheme}_proxy_pass"] || ENV["#{_SCHEME}_PROXY_PASS"]
-
-      uri.user     = Gem::UriFormatter.new(user).escape
-      uri.password = Gem::UriFormatter.new(password).escape
+      # Probably we have http_proxy_* variables?
+      uri.user = Gem::UriFormatter.new(ENV['http_proxy_user'] || ENV['HTTP_PROXY_USER']).escape
+      uri.password = Gem::UriFormatter.new(ENV['http_proxy_pass'] || ENV['HTTP_PROXY_PASS']).escape
     end
 
     uri
diff --git a/lib/rubygems/request_set.rb b/lib/rubygems/request_set.rb
index fb54e34..d90c3d4 100644
--- a/lib/rubygems/request_set.rb
+++ b/lib/rubygems/request_set.rb
@@ -1,4 +1,8 @@
 require 'rubygems'
+require 'rubygems/dependency'
+require 'rubygems/dependency_resolver'
+require 'rubygems/dependency_list'
+require 'rubygems/installer'
 require 'tsort'
 
 ##
@@ -28,37 +32,11 @@ class Gem::RequestSet
   attr_accessor :development
 
   ##
-  # The set of git gems imported via load_gemdeps.
-
-  attr_reader :git_set # :nodoc:
-
-  ##
-  # When true, dependency resolution is not performed, only the requested gems
-  # are installed.
-
-  attr_accessor :ignore_dependencies
-
-  ##
-  # When false no remote sets are used for resolving gems.
-
-  attr_accessor :remote
-
-  ##
-  # Sets used for resolution
-
-  attr_reader :sets # :nodoc:
-
-  ##
   # Treat missing dependencies as silent errors
 
   attr_accessor :soft_missing
 
   ##
-  # The set of vendor gems imported via load_gemdeps.
-
-  attr_reader :vendor_set # :nodoc:
-
-  ##
   # Creates a RequestSet for a list of Gem::Dependency objects, +deps+.  You
   # can then #resolve and #install the resolved list of dependencies.
   #
@@ -70,19 +48,12 @@ class Gem::RequestSet
   def initialize *deps
     @dependencies = deps
 
-    @always_install      = []
-    @dependency_names    = {}
-    @development         = false
-    @git_set             = nil
-    @ignore_dependencies = false
-    @install_dir         = Gem.dir
-    @remote              = true
-    @requests            = []
-    @sets                = []
-    @soft_missing        = false
-    @sorted              = nil
-    @specs               = nil
-    @vendor_set          = nil
+    @always_install = []
+    @development    = false
+    @requests       = []
+    @soft_missing   = false
+    @sorted         = nil
+    @specs          = nil
 
     yield self if block_given?
   end
@@ -91,30 +62,17 @@ class Gem::RequestSet
   # Declare that a gem of name +name+ with +reqs+ requirements is needed.
 
   def gem name, *reqs
-    if dep = @dependency_names[name] then
-      dep.requirement.concat reqs
-    else
-      dep = Gem::Dependency.new name, reqs
-      @dependency_names[name] = dep
-      @dependencies << dep
-    end
+    @dependencies << Gem::Dependency.new(name, reqs)
   end
 
   ##
   # Add +deps+ Gem::Dependency objects to the set.
 
   def import deps
-    @dependencies.concat deps
+    @dependencies += deps
   end
 
-  ##
-  # Installs gems for this RequestSet using the Gem::Installer +options+.
-  #
-  # If a +block+ is given an activation +request+ and +installer+ are yielded.
-  # The +installer+ will be +nil+ if a gem matching the request was already
-  # installed.
-
-  def install options, &block # :yields: request, installer
+  def install options, &block
     if dir = options[:install_dir]
       return install_into dir, false, options, &block
     end
@@ -124,13 +82,10 @@ class Gem::RequestSet
     specs = []
 
     sorted_requests.each do |req|
-      if req.installed? then
-        req.spec.spec.build_extensions
-
-        if @always_install.none? { |spec| spec == req.spec.spec } then
-          yield req, nil if block_given?
-          next
-        end
+      if req.installed? and
+         @always_install.none? { |spec| spec == req.spec.spec } then
+        yield req, nil if block_given?
+        next
       end
 
       path = req.download cache_dir
@@ -145,46 +100,7 @@ class Gem::RequestSet
     specs
   end
 
-  ##
-  # Installs from the gem dependencies files in the +:gemdeps+ option in
-  # +options+, yielding to the +block+ as in #install.
-  #
-  # If +:without_groups+ is given in the +options+, those groups in the gem
-  # dependencies file are not used.  See Gem::Installer for other +options+.
-
-  def install_from_gemdeps options, &block
-    gemdeps = options[:gemdeps]
-
-    @install_dir = options[:install_dir] || Gem.dir
-    @remote      = options[:domain] != :local
-
-    load_gemdeps gemdeps, options[:without_groups]
-
-    resolve
-
-    if options[:explain]
-      puts "Gems to install:"
-
-      specs.map { |s| s.full_name }.sort.each do |s|
-        puts "  #{s}"
-      end
-
-      if Gem.configuration.really_verbose
-        @resolver.stats.display
-      end
-    else
-      installed = install options, &block
-
-      lockfile = Gem::RequestSet::Lockfile.new self, gemdeps
-      lockfile.write
-
-      installed
-    end
-  end
-
   def install_into dir, force = true, options = {}
-    gem_home, ENV['GEM_HOME'] = ENV['GEM_HOME'], dir
-
     existing = force ? [] : specs_in(dir)
     existing.delete_if { |s| @always_install.include? s }
 
@@ -192,43 +108,39 @@ class Gem::RequestSet
 
     installed = []
 
-    options[:install_dir] = dir
-    options[:only_install_dir] = true
+    sorted_requests.each do |req|
+      if existing.find { |s| s.full_name == req.spec.full_name }
+        yield req, nil if block_given?
+        next
+      end
 
-    sorted_requests.each do |request|
-      spec = request.spec
+      path = req.download(dir)
 
-      if existing.find { |s| s.full_name == spec.full_name } then
-        yield request, nil if block_given?
+      unless path then # already installed
+        yield req, nil if block_given?
         next
       end
 
-      spec.install options do |installer|
-        yield request, installer if block_given?
-      end
+      options[:install_dir] = dir
+      options[:only_install_dir] = true
+
+      inst = Gem::Installer.new path, options
+
+      yield req, inst if block_given?
+
+      inst.install
 
-      installed << request
+      installed << req
     end
 
     installed
-  ensure
-    ENV['GEM_HOME'] = gem_home
   end
 
   ##
   # Load a dependency management file.
 
-  def load_gemdeps path, without_groups = []
-    @git_set    = Gem::Resolver::GitSet.new
-    @vendor_set = Gem::Resolver::VendorSet.new
-
-    @git_set.root_dir = @install_dir
-
-    lockfile = Gem::RequestSet::Lockfile.new self, path
-    lockfile.parse
-
-    gf = Gem::RequestSet::GemDependencyAPI.new self, path
-    gf.without_groups = without_groups if without_groups
+  def load_gemdeps path
+    gf = Gem::RequestSet::GemDepedencyAPI.new self, path
     gf.load
   end
 
@@ -236,20 +148,10 @@ class Gem::RequestSet
   # Resolve the requested dependencies and return an Array of Specification
   # objects to be activated.
 
-  def resolve set = Gem::Resolver::BestSet.new
-    @sets << set
-    @sets << @git_set
-    @sets << @vendor_set
-
-    set = Gem::Resolver.compose_sets(*@sets)
-    set.remote = @remote
-
-    resolver = Gem::Resolver.new @dependencies, set
-    resolver.development         = @development
-    resolver.ignore_dependencies = @ignore_dependencies
-    resolver.soft_missing        = @soft_missing
-
-    @resolver = resolver
+  def resolve set = nil
+    resolver = Gem::DependencyResolver.new @dependencies, set
+    resolver.development  = @development
+    resolver.soft_missing = @soft_missing
 
     @requests = resolver.resolve
   end
@@ -259,7 +161,7 @@ class Gem::RequestSet
   # and return an Array of Specification objects to be activated.
 
   def resolve_current
-    resolve Gem::Resolver::CurrentSet.new
+    resolve Gem::DependencyResolver::CurrentSet.new
   end
 
   def sorted_requests
@@ -292,7 +194,7 @@ class Gem::RequestSet
         end
       else
         unless @soft_missing
-          raise Gem::DependencyError, "Unresolved dependency found during sorting - #{dep} (requested by #{node.spec.full_name})"
+          raise Gem::DependencyError, "Unresolved depedency found during sorting - #{dep}"
         end
       end
     end
@@ -301,4 +203,3 @@ class Gem::RequestSet
 end
 
 require 'rubygems/request_set/gem_dependency_api'
-require 'rubygems/request_set/lockfile'
diff --git a/lib/rubygems/request_set/gem_dependency_api.rb b/lib/rubygems/request_set/gem_dependency_api.rb
index efce979..178ed1b 100644
--- a/lib/rubygems/request_set/gem_dependency_api.rb
+++ b/lib/rubygems/request_set/gem_dependency_api.rb
@@ -1,521 +1,39 @@
 ##
-# A semi-compatible DSL for the Bundler Gemfile and Isolate formats.
+# A semi-compatible DSL for Bundler's Gemfile format
 
-class Gem::RequestSet::GemDependencyAPI
-
-  ENGINE_MAP = { # :nodoc:
-    :jruby        => %w[jruby],
-    :jruby_18     => %w[jruby],
-    :jruby_19     => %w[jruby],
-    :maglev       => %w[maglev],
-    :mri          => %w[ruby],
-    :mri_18       => %w[ruby],
-    :mri_19       => %w[ruby],
-    :mri_20       => %w[ruby],
-    :mri_21       => %w[ruby],
-    :rbx          => %w[rbx],
-    :ruby         => %w[ruby rbx maglev],
-    :ruby_18      => %w[ruby rbx maglev],
-    :ruby_19      => %w[ruby rbx maglev],
-    :ruby_20      => %w[ruby rbx maglev],
-    :ruby_21      => %w[ruby rbx maglev],
-  }
-
-  x86_mingw = Gem::Platform.new 'x86-mingw32'
-  x64_mingw = Gem::Platform.new 'x64-mingw32'
-
-  PLATFORM_MAP = { # :nodoc:
-    :jruby        => Gem::Platform::RUBY,
-    :jruby_18     => Gem::Platform::RUBY,
-    :jruby_19     => Gem::Platform::RUBY,
-    :maglev       => Gem::Platform::RUBY,
-    :mingw        => x86_mingw,
-    :mingw_18     => x86_mingw,
-    :mingw_19     => x86_mingw,
-    :mingw_20     => x86_mingw,
-    :mingw_21     => x86_mingw,
-    :mri          => Gem::Platform::RUBY,
-    :mri_18       => Gem::Platform::RUBY,
-    :mri_19       => Gem::Platform::RUBY,
-    :mri_20       => Gem::Platform::RUBY,
-    :mri_21       => Gem::Platform::RUBY,
-    :mswin        => Gem::Platform::RUBY,
-    :rbx          => Gem::Platform::RUBY,
-    :ruby         => Gem::Platform::RUBY,
-    :ruby_18      => Gem::Platform::RUBY,
-    :ruby_19      => Gem::Platform::RUBY,
-    :ruby_20      => Gem::Platform::RUBY,
-    :ruby_21      => Gem::Platform::RUBY,
-    :x64_mingw    => x64_mingw,
-    :x64_mingw_20 => x64_mingw,
-    :x64_mingw_21 => x64_mingw
-  }
-
-  gt_eq_0        = Gem::Requirement.new '>= 0'
-  tilde_gt_1_8_0 = Gem::Requirement.new '~> 1.8.0'
-  tilde_gt_1_9_0 = Gem::Requirement.new '~> 1.9.0'
-  tilde_gt_2_0_0 = Gem::Requirement.new '~> 2.0.0'
-  tilde_gt_2_1_0 = Gem::Requirement.new '~> 2.1.0'
-
-  VERSION_MAP = { # :nodoc:
-    :jruby        => gt_eq_0,
-    :jruby_18     => tilde_gt_1_8_0,
-    :jruby_19     => tilde_gt_1_9_0,
-    :maglev       => gt_eq_0,
-    :mingw        => gt_eq_0,
-    :mingw_18     => tilde_gt_1_8_0,
-    :mingw_19     => tilde_gt_1_9_0,
-    :mingw_20     => tilde_gt_2_0_0,
-    :mingw_21     => tilde_gt_2_1_0,
-    :mri          => gt_eq_0,
-    :mri_18       => tilde_gt_1_8_0,
-    :mri_19       => tilde_gt_1_9_0,
-    :mri_20       => tilde_gt_2_0_0,
-    :mri_21       => tilde_gt_2_1_0,
-    :mswin        => gt_eq_0,
-    :rbx          => gt_eq_0,
-    :ruby         => gt_eq_0,
-    :ruby_18      => tilde_gt_1_8_0,
-    :ruby_19      => tilde_gt_1_9_0,
-    :ruby_20      => tilde_gt_2_0_0,
-    :ruby_21      => tilde_gt_2_1_0,
-    :x64_mingw    => gt_eq_0,
-    :x64_mingw_20 => tilde_gt_2_0_0,
-    :x64_mingw_21 => tilde_gt_2_1_0,
-  }
-
-  WINDOWS = { # :nodoc:
-    :mingw        => :only,
-    :mingw_18     => :only,
-    :mingw_19     => :only,
-    :mingw_20     => :only,
-    :mingw_21     => :only,
-    :mri          => :never,
-    :mri_18       => :never,
-    :mri_19       => :never,
-    :mri_20       => :never,
-    :mri_21       => :never,
-    :mswin        => :only,
-    :rbx          => :never,
-    :ruby         => :never,
-    :ruby_18      => :never,
-    :ruby_19      => :never,
-    :ruby_20      => :never,
-    :ruby_21      => :never,
-    :x64_mingw    => :only,
-    :x64_mingw_20 => :only,
-    :x64_mingw_21 => :only,
-  }
-
-  ##
-  # A set of gems that are loaded via the +:git+ option to #gem
-
-  attr_reader :git_set # :nodoc:
-
-  ##
-  # A Hash containing gem names and files to require from those gems.
-
-  attr_reader :requires # :nodoc:
-
-  ##
-  # A set of gems that are loaded via the +:path+ option to #gem
-
-  attr_reader :vendor_set # :nodoc:
-
-  ##
-  # The groups of gems to exclude from installation
-
-  attr_accessor :without_groups # :nodoc:
-
-  ##
-  # Creates a new GemDependencyAPI that will add dependencies to the
-  # Gem::RequestSet +set+ based on the dependency API description in +path+.
+class Gem::RequestSet::GemDepedencyAPI
 
   def initialize set, path
     @set = set
     @path = path
-
-    @current_groups     = nil
-    @current_platform   = nil
-    @current_repository = nil
-    @default_sources    = true
-    @git_set            = @set.git_set
-    @requires           = Hash.new { |h, name| h[name] = [] }
-    @vendor_set         = @set.vendor_set
-    @gem_sources        = {}
-    @without_groups     = []
   end
 
-  ##
-  # Adds +dependencies+ to the request set if any of the +groups+ are allowed.
-  # This is used for gemspec dependencies.
-
-  def add_dependencies groups, dependencies # :nodoc:
-    return unless (groups & @without_groups).empty?
-
-    dependencies.each do |dep|
-      @set.gem dep.name, *dep.requirement
-    end
-  end
-
-  private :add_dependencies
-
-  ##
-  # Finds a gemspec with the given +name+ that lives at +path+.
-
-  def find_gemspec name, path # :nodoc:
-    glob = File.join path, "#{name}.gemspec"
-
-    spec_files = Dir[glob]
-
-    case spec_files.length
-    when 1 then
-      spec_file = spec_files.first
-
-      spec = Gem::Specification.load spec_file
-
-      return spec if spec
-
-      raise ArgumentError, "invalid gemspec #{spec_file}"
-    when 0 then
-      raise ArgumentError, "no gemspecs found at #{Dir.pwd}"
-    else
-      raise ArgumentError,
-        "found multiple gemspecs at #{Dir.pwd}, " +
-        "use the name: option to specify the one you want"
-    end
-  end
-
-  ##
-  # Loads the gem dependency file
-
   def load
     instance_eval File.read(@path).untaint, @path, 1
   end
 
-  ##
-  # :category: Gem Dependencies DSL
-  # :call-seq:
-  #   gem(name)
-  #   gem(name, *requirements)
-  #   gem(name, *requirements, options)
-  #
-  # Specifies a gem dependency with the given +name+ and +requirements+.  You
-  # may also supply +options+ following the +requirements+
-
-  def gem name, *requirements
-    options = requirements.pop if requirements.last.kind_of?(Hash)
-    options ||= {}
-
-    options[:git] = @current_repository if @current_repository
-
-    source_set = false
-
-    source_set ||= gem_path   name, options
-    source_set ||= gem_git    name, options
-    source_set ||= gem_github name, options
-
-    return unless gem_platforms options
-
-    groups = gem_group name, options
-
-    return unless (groups & @without_groups).empty?
-
-    pin_gem_source name, :default unless source_set
-
-    gem_requires name, options
-
-    @set.gem name, *requirements
-  end
-
-  ##
-  # Handles the git: option from +options+ for gem +name+.
-  #
-  # Returns +true+ if the path option was handled.
+  # :category: Bundler Gemfile DSL
 
-  def gem_git name, options # :nodoc:
-    if gist = options.delete(:gist) then
-      options[:git] = "https://gist.github.com/#{gist}.git"
-    end
-
-    return unless repository = options.delete(:git)
-
-    pin_gem_source name, :git, repository
-
-    reference = nil
-    reference ||= options.delete :ref
-    reference ||= options.delete :branch
-    reference ||= options.delete :tag
-    reference ||= 'master'
-
-    submodules = options.delete :submodules
+  def gem name, *reqs
+    # Ignore the opts for now.
+    reqs.pop if reqs.last.kind_of?(Hash)
 
-    @git_set.add_git_gem name, repository, reference, submodules
-
-    true
+    @set.gem name, *reqs
   end
 
-  private :gem_git
-
-  ##
-  # Handles the github: option from +options+ for gem +name+.
-  #
-  # Returns +true+ if the path option was handled.
-
-  def gem_github name, options # :nodoc:
-    return unless path = options.delete(:github)
-
-    options[:git] = "git://github.com/#{path}.git"
-
-    gem_git name, options
-
-    true
-  end
-
-  private :gem_github
-
-  ##
-  # Handles the :group and :groups +options+ for the gem with the given
-  # +name+.
-
-  def gem_group name, options # :nodoc:
-    g = options.delete :group
-    all_groups  = g ? Array(g) : []
-
-    groups = options.delete :groups
-    all_groups |= groups if groups
-
-    all_groups |= @current_groups if @current_groups
-
-    all_groups
+  def group *what
   end
 
-  private :gem_group
-
-  ##
-  # Handles the path: option from +options+ for gem +name+.
-  #
-  # Returns +true+ if the path option was handled.
-
-  def gem_path name, options # :nodoc:
-    return unless directory = options.delete(:path)
-
-    pin_gem_source name, :path, directory
-
-    @vendor_set.add_vendor_gem name, directory
-
-    true
-  end
-
-  private :gem_path
-
-  ##
-  # Handles the platforms: option from +options+.  Returns true if the
-  # platform matches the current platform.
-
-  def gem_platforms options # :nodoc:
-    platform_names = Array(options.delete :platforms)
-    platform_names << @current_platform if @current_platform
-
-    return true if platform_names.empty?
-
-    platform_names.any? do |platform_name|
-      raise ArgumentError, "unknown platform #{platform_name.inspect}" unless
-        platform = PLATFORM_MAP[platform_name]
-
-      next false unless Gem::Platform.match platform
-
-      if engines = ENGINE_MAP[platform_name] then
-        next false unless engines.include? Gem.ruby_engine
-      end
-
-      case WINDOWS[platform_name]
-      when :only then
-        next false unless Gem.win_platform?
-      when :never then
-        next false if Gem.win_platform?
-      end
-
-      VERSION_MAP[platform_name].satisfied_by? Gem.ruby_version
-    end
-  end
-
-  private :gem_platforms
-
-  ##
-  # Handles the require: option from +options+ and adds those files, or the
-  # default file to the require list for +name+.
-
-  def gem_requires name, options # :nodoc:
-    if options.include? :require then
-      if requires = options.delete(:require) then
-        @requires[name].concat Array requires
-      end
-    else
-      @requires[name] << name
-    end
-  end
-
-  private :gem_requires
-
-  ##
-  # :category: Gem Dependencies DSL
-  #
-  # Block form for specifying gems from a git +repository+.
-
-  def git repository
-    @current_repository = repository
-
-    yield
-
-  ensure
-    @current_repository = nil
-  end
-
-  ##
-  # Returns the basename of the file the dependencies were loaded from
-
-  def gem_deps_file # :nodoc:
-    File.basename @path
-  end
-
-  ##
-  # :category: Gem Dependencies DSL
-  #
-  # Loads dependencies from a gemspec file.
-
-  def gemspec options = {}
-    name              = options.delete(:name) || '{,*}'
-    path              = options.delete(:path) || '.'
-    development_group = options.delete(:development_group) || :development
-
-    spec = find_gemspec name, path
-
-    groups = gem_group spec.name, {}
-
-    add_dependencies groups, spec.runtime_dependencies
-
-    groups << development_group
-
-    add_dependencies groups, spec.development_dependencies
-
-    gem_requires spec.name, options
-  end
-
-  ##
-  # :category: Gem Dependencies DSL
-  # Block form for placing a dependency in the given +groups+.
-
-  def group *groups
-    @current_groups = groups
-
-    yield
-
-  ensure
-    @current_groups = nil
-  end
-
-  ##
-  # Pins the gem +name+ to the given +source+.  Adding a gem with the same
-  # name from a different +source+ will raise an exception.
-
-  def pin_gem_source name, type = :default, source = nil
-    source_description =
-      case type
-      when :default then '(default)'
-      when :path    then "path: #{source}"
-      when :git     then "git: #{source}"
-      else               '(unknown)'
-      end
-
-    raise ArgumentError,
-      "duplicate source #{source_description} for gem #{name}" if
-        @gem_sources.fetch(name, source) != source
-
-    @gem_sources[name] = source
-  end
-
-  private :pin_gem_source
-
-  ##
-  # :category: Gem Dependencies DSL
-  #
-  # Block form for restricting gems to a particular platform.
-
   def platform what
-    @current_platform = what
-
-    yield
-
-  ensure
-    @current_platform = nil
-  end
-
-  ##
-  # :category: Gem Dependencies DSL
-  #
-  # Block form for restricting gems to a particular platform.
-
-  alias :platforms :platform
-
-  ##
-  # :category: Gem Dependencies DSL
-  # Restricts this gem dependencies file to the given ruby +version+.  The
-  # +:engine+ options from Bundler are currently ignored.
-
-  def ruby version, options = {}
-    engine         = options[:engine]
-    engine_version = options[:engine_version]
-
-    raise ArgumentError,
-          'you must specify engine_version along with the ruby engine' if
-            engine and not engine_version
-
-    unless RUBY_VERSION == version then
-      message = "Your Ruby version is #{RUBY_VERSION}, " +
-                "but your #{gem_deps_file} requires #{version}"
-
-      raise Gem::RubyVersionMismatch, message
+    if what == :ruby
+      yield
     end
-
-    if engine and engine != Gem.ruby_engine then
-      message = "Your ruby engine is #{Gem.ruby_engine}, " +
-                "but your #{gem_deps_file} requires #{engine}"
-
-      raise Gem::RubyVersionMismatch, message
-    end
-
-    if engine_version then
-      my_engine_version = Object.const_get "#{Gem.ruby_engine.upcase}_VERSION"
-
-      if engine_version != my_engine_version then
-        message =
-          "Your ruby engine version is #{Gem.ruby_engine} #{my_engine_version}, " +
-          "but your #{gem_deps_file} requires #{engine} #{engine_version}"
-
-        raise Gem::RubyVersionMismatch, message
-      end
-    end
-
-    return true
   end
 
-  ##
-  # :category: Gem Dependencies DSL
-  #
-  # Sets +url+ as a source for gems for this dependency API.
+  alias :platforms :platform
 
   def source url
-    Gem.sources.clear if @default_sources
-
-    @default_sources = false
-
-    Gem.sources << url
   end
 
-  # TODO: remove this typo name at RubyGems 3.0
-
-  Gem::RequestSet::GemDepedencyAPI = self # :nodoc:
-
 end
 
diff --git a/lib/rubygems/request_set/lockfile.rb b/lib/rubygems/request_set/lockfile.rb
deleted file mode 100644
index 0433d2a..0000000
--- a/lib/rubygems/request_set/lockfile.rb
+++ /dev/null
@@ -1,584 +0,0 @@
-require 'strscan'
-
-##
-# Parses a gem.deps.rb.lock file and constructs a LockSet containing the
-# dependencies found inside.  If the lock file is missing no LockSet is
-# constructed.
-
-class Gem::RequestSet::Lockfile
-
-  ##
-  # Raised when a lockfile cannot be parsed
-
-  class ParseError < Gem::Exception
-
-    ##
-    # The column where the error was encountered
-
-    attr_reader :column
-
-    ##
-    # The line where the error was encountered
-
-    attr_reader :line
-
-    ##
-    # The location of the lock file
-
-    attr_reader :path
-
-    ##
-    # Raises a ParseError with the given +message+ which was encountered at a
-    # +line+ and +column+ while parsing.
-
-    def initialize message, column, line, path
-      @line   = line
-      @column = column
-      @path   = path
-      super "#{message} (at line #{line} column #{column})"
-    end
-
-  end
-
-  ##
-  # The platforms for this Lockfile
-
-  attr_reader :platforms
-
-  ##
-  # Creates a new Lockfile for the given +request_set+ and +gem_deps_file+
-  # location.
-
-  def initialize request_set, gem_deps_file
-    @set           = request_set
-    @gem_deps_file = File.expand_path(gem_deps_file)
-    @gem_deps_dir  = File.dirname(@gem_deps_file)
-
-    @current_token  = nil
-    @line           = 0
-    @line_pos       = 0
-    @platforms      = []
-    @tokens         = []
-  end
-
-  def add_DEPENDENCIES out # :nodoc:
-    out << "DEPENDENCIES"
-
-    @requests.sort_by { |r| r.name }.each do |request|
-      spec = request.spec
-
-      if [Gem::Resolver::VendorSpecification,
-          Gem::Resolver::GitSpecification].include? spec.class then
-        out << "  #{request.name}!"
-      else
-        requirement = request.request.dependency.requirement
-
-        out << "  #{request.name}#{requirement.for_lockfile}"
-      end
-    end
-
-    out << nil
-  end
-
-  def add_GEM out # :nodoc:
-    return if @spec_groups.empty?
-
-    source_groups = @spec_groups.values.flatten.group_by do |request|
-      request.spec.source.uri
-    end
-
-    source_groups.sort_by { |group,| group.to_s }.map do |group, requests|
-      out << "GEM"
-      out << "  remote: #{group}"
-      out << "  specs:"
-
-      requests.sort_by { |request| request.name }.each do |request|
-        platform = "-#{request.spec.platform}" unless
-          Gem::Platform::RUBY == request.spec.platform
-
-        out << "    #{request.name} (#{request.version}#{platform})"
-
-        request.full_spec.dependencies.sort.each do |dependency|
-          requirement = dependency.requirement
-          out << "      #{dependency.name}#{requirement.for_lockfile}"
-        end
-      end
-      out << nil
-    end
-  end
-
-  def add_GIT out
-    return unless git_requests =
-      @spec_groups.delete(Gem::Resolver::GitSpecification)
-
-    by_repository_revision = git_requests.group_by do |request|
-      source = request.spec.source
-      [source.repository, source.rev_parse]
-    end
-
-    out << "GIT"
-    by_repository_revision.each do |(repository, revision), requests|
-      out << "  remote: #{repository}"
-      out << "  revision: #{revision}"
-      out << "  specs:"
-
-      requests.sort_by { |request| request.name }.each do |request|
-        out << "    #{request.name} (#{request.version})"
-
-        dependencies = request.spec.dependencies.sort_by { |dep| dep.name }
-        dependencies.each do |dep|
-          out << "      #{dep.name}#{dep.requirement.for_lockfile}"
-        end
-      end
-    end
-
-    out << nil
-  end
-
-  def relative_path_from dest, base # :nodoc:
-    dest = File.expand_path(dest)
-    base = File.expand_path(base)
-
-    if dest.index(base) == 0
-      return dest[base.size+1..-1]
-    else
-      dest
-    end
-  end
-
-  def add_PATH out # :nodoc:
-    return unless path_requests =
-      @spec_groups.delete(Gem::Resolver::VendorSpecification)
-
-    out << "PATH"
-    path_requests.each do |request|
-      directory = File.expand_path(request.spec.source.uri)
-
-      out << "  remote: #{relative_path_from directory, @gem_deps_dir}"
-      out << "  specs:"
-      out << "    #{request.name} (#{request.version})"
-    end
-
-    out << nil
-  end
-
-  def add_PLATFORMS out # :nodoc:
-    out << "PLATFORMS"
-
-    platforms = @requests.map { |request| request.spec.platform }.uniq
-    platforms.delete Gem::Platform::RUBY if platforms.length > 1
-
-    platforms.each do |platform|
-      out << "  #{platform}"
-    end
-
-    out << nil
-  end
-
-  ##
-  # Gets the next token for a Lockfile
-
-  def get expected_types = nil, expected_value = nil # :nodoc:
-    @current_token = @tokens.shift
-
-    type, value, column, line = @current_token
-
-    if expected_types and not Array(expected_types).include? type then
-      unget
-
-      message = "unexpected token [#{type.inspect}, #{value.inspect}], " +
-                "expected #{expected_types.inspect}"
-
-      raise ParseError.new message, column, line, "#{@gem_deps_file}.lock"
-    end
-
-    if expected_value and expected_value != value then
-      unget
-
-      message = "unexpected token [#{type.inspect}, #{value.inspect}], " +
-                "expected [#{expected_types.inspect}, " +
-                "#{expected_value.inspect}]"
-
-      raise ParseError.new message, column, line, "#{@gem_deps_file}.lock"
-    end
-
-    @current_token
-  end
-
-  def parse # :nodoc:
-    tokenize
-
-    until @tokens.empty? do
-      type, data, column, line = get
-
-      case type
-      when :section then
-        skip :newline
-
-        case data
-        when 'DEPENDENCIES' then
-          parse_DEPENDENCIES
-        when 'GIT' then
-          parse_GIT
-        when 'GEM' then
-          parse_GEM
-        when 'PATH' then
-          parse_PATH
-        when 'PLATFORMS' then
-          parse_PLATFORMS
-        else
-          type, = get until @tokens.empty? or peek.first == :section
-        end
-      else
-        raise "BUG: unhandled token #{type} (#{data.inspect}) at line #{line} column #{column}"
-      end
-    end
-  end
-
-  def parse_DEPENDENCIES # :nodoc:
-    while not @tokens.empty? and :text == peek.first do
-      _, name, = get :text
-
-      requirements = []
-
-      case peek[0]
-      when :bang then
-        get :bang
-
-        spec = @set.sets.select { |set|
-          Gem::Resolver::GitSet    === set or
-          Gem::Resolver::VendorSet === set
-        }.map { |set|
-          set.specs[name]
-        }.first
-
-        requirements << spec.version
-      when :l_paren then
-        get :l_paren
-
-        loop do
-          _, op,      = get :requirement
-          _, version, = get :text
-
-          requirements << "#{op} #{version}"
-
-          break unless peek[0] == :comma
-
-          get :comma
-        end
-
-        get :r_paren
-      end
-
-      @set.gem name, *requirements
-
-      skip :newline
-    end
-  end
-
-  def parse_GEM # :nodoc:
-    get :entry, 'remote'
-    _, data, = get :text
-
-    source = Gem::Source.new data
-
-    skip :newline
-
-    get :entry, 'specs'
-
-    skip :newline
-
-    set = Gem::Resolver::LockSet.new source
-    last_spec = nil
-
-    while not @tokens.empty? and :text == peek.first do
-      _, name, column, = get :text
-
-      case peek[0]
-      when :newline then
-        last_spec.add_dependency Gem::Dependency.new name if column == 6
-      when :l_paren then
-        get :l_paren
-
-        type, data, = get [:text, :requirement]
-
-        if type == :text and column == 4 then
-          version, platform = data.split '-', 2
-
-          platform =
-            platform ? Gem::Platform.new(platform) : Gem::Platform::RUBY
-
-          last_spec = set.add name, version, platform
-        else
-          dependency = parse_dependency name, data
-
-          last_spec.add_dependency dependency
-        end
-
-        get :r_paren
-      else
-        raise "BUG: unknown token #{peek}"
-      end
-
-      skip :newline
-    end
-
-    @set.sets << set
-  end
-
-  def parse_GIT # :nodoc:
-    get :entry, 'remote'
-    _, repository, = get :text
-
-    skip :newline
-
-    get :entry, 'revision'
-    _, revision, = get :text
-
-    skip :newline
-
-    get :entry, 'specs'
-
-    skip :newline
-
-    set = Gem::Resolver::GitSet.new
-    last_spec = nil
-
-    while not @tokens.empty? and :text == peek.first do
-      _, name, column, = get :text
-
-      case peek[0]
-      when :newline then
-        last_spec.add_dependency Gem::Dependency.new name if column == 6
-      when :l_paren then
-        get :l_paren
-
-        type, data, = get [:text, :requirement]
-
-        if type == :text and column == 4 then
-          last_spec = set.add_git_spec name, data, repository, revision, true
-        else
-          dependency = parse_dependency name, data
-
-          last_spec.spec.dependencies << dependency
-        end
-
-        get :r_paren
-      else
-        raise "BUG: unknown token #{peek}"
-      end
-
-      skip :newline
-    end
-
-    @set.sets << set
-  end
-
-  def parse_PATH # :nodoc:
-    get :entry, 'remote'
-    _, directory, = get :text
-
-    skip :newline
-
-    get :entry, 'specs'
-
-    skip :newline
-
-    set = Gem::Resolver::VendorSet.new
-    last_spec = nil
-
-    while not @tokens.empty? and :text == peek.first do
-      _, name, column, = get :text
-
-      case peek[0]
-      when :newline then
-        last_spec.add_dependency Gem::Dependency.new name if column == 6
-      when :l_paren then
-        get :l_paren
-
-        type, data, = get [:text, :requirement]
-
-        if type == :text and column == 4 then
-          last_spec = set.add_vendor_gem name, directory
-        else
-          dependency = parse_dependency name, data
-
-          last_spec.spec.dependencies << dependency
-        end
-
-        get :r_paren
-      else
-        raise "BUG: unknown token #{peek}"
-      end
-
-      skip :newline
-    end
-
-    @set.sets << set
-  end
-
-  def parse_PLATFORMS # :nodoc:
-    while not @tokens.empty? and :text == peek.first do
-      _, name, = get :text
-
-      @platforms << name
-
-      skip :newline
-    end
-  end
-
-  ##
-  # Parses the requirements following the dependency +name+ and the +op+ for
-  # the first token of the requirements and returns a Gem::Dependency object.
-
-  def parse_dependency name, op # :nodoc:
-    return Gem::Dependency.new name unless peek[0] == :text
-
-    _, version, = get :text
-
-    requirements = ["#{op} #{version}"]
-
-    while peek[0] == :comma do
-      get :comma
-      _, op,      = get :requirement
-      _, version, = get :text
-
-      requirements << "#{op} #{version}"
-    end
-
-    Gem::Dependency.new name, requirements
-  end
-
-  ##
-  # Peeks at the next token for Lockfile
-
-  def peek # :nodoc:
-    @tokens.first || [:EOF]
-  end
-
-  def skip type # :nodoc:
-    get while not @tokens.empty? and peek.first == type
-  end
-
-  ##
-  # The contents of the lock file.
-
-  def to_s
-    @set.resolve
-
-    out = []
-
-    @requests = @set.sorted_requests
-
-    @spec_groups = @requests.group_by do |request|
-      request.spec.class
-    end
-
-    add_PATH out
-
-    add_GIT out
-
-    add_GEM out
-
-    add_PLATFORMS out
-
-    add_DEPENDENCIES out
-
-    out.join "\n"
-  end
-
-  ##
-  # Calculates the column (by byte) and the line of the current token based on
-  # +byte_offset+.
-
-  def token_pos byte_offset # :nodoc:
-    [byte_offset - @line_pos, @line]
-  end
-
-  ##
-  # Converts a lock file into an Array of tokens.  If the lock file is missing
-  # an empty Array is returned.
-
-  def tokenize # :nodoc:
-    @line     = 0
-    @line_pos = 0
-
-    @platforms     = []
-    @tokens        = []
-    @current_token = nil
-
-    lock_file = "#{@gem_deps_file}.lock"
-
-    @input = File.read lock_file
-    s      = StringScanner.new @input
-
-    until s.eos? do
-      pos = s.pos
-
-      pos = s.pos if leading_whitespace = s.scan(/ +/)
-
-      if s.scan(/[<|=>]{7}/) then
-        message = "your #{lock_file} contains merge conflict markers"
-        column, line = token_pos pos
-
-        raise ParseError.new message, column, line, lock_file
-      end
-
-      @tokens <<
-        case
-        when s.scan(/\r?\n/) then
-          token = [:newline, nil, *token_pos(pos)]
-          @line_pos = s.pos
-          @line += 1
-          token
-        when s.scan(/[A-Z]+/) then
-          if leading_whitespace then
-            text = s.matched
-            text += s.scan(/[^\s)]*/).to_s # in case of no match
-            [:text, text, *token_pos(pos)]
-          else
-            [:section, s.matched, *token_pos(pos)]
-          end
-        when s.scan(/([a-z]+):\s/) then
-          s.pos -= 1 # rewind for possible newline
-          [:entry, s[1], *token_pos(pos)]
-        when s.scan(/\(/) then
-          [:l_paren, nil, *token_pos(pos)]
-        when s.scan(/\)/) then
-          [:r_paren, nil, *token_pos(pos)]
-        when s.scan(/<=|>=|=|~>|<|>|!=/) then
-          [:requirement, s.matched, *token_pos(pos)]
-        when s.scan(/,/) then
-          [:comma, nil, *token_pos(pos)]
-        when s.scan(/!/) then
-          [:bang, nil, *token_pos(pos)]
-        when s.scan(/[^\s),!]*/) then
-          [:text, s.matched, *token_pos(pos)]
-        else
-          raise "BUG: can't create token for: #{s.string[s.pos..-1].inspect}"
-        end
-    end
-
-    @tokens
-  rescue Errno::ENOENT
-    @tokens
-  end
-
-  ##
-  # Ungets the last token retrieved by #get
-
-  def unget # :nodoc:
-    @tokens.unshift @current_token
-  end
-
-  ##
-  # Writes the lock file alongside the gem dependencies file
-
-  def write
-    open "#{@gem_deps_file}.lock", 'w' do |io|
-      io.write to_s
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/requirement.rb b/lib/rubygems/requirement.rb
index ece9d00..ed76892 100644
--- a/lib/rubygems/requirement.rb
+++ b/lib/rubygems/requirement.rb
@@ -1,3 +1,13 @@
+##
+# A Requirement is a set of one or more version restrictions. It supports a
+# few (<tt>=, !=, >, <, >=, <=, ~></tt>) different restriction operators.
+
+# REFACTOR: The fact that a requirement is singular or plural is kind of
+# awkward. Is Requirement the right name for this? Or should it be one
+# [op, number] pair, and we call the list of requirements something else?
+# Since a Requirement is held by a Dependency, maybe this should be made
+# singular and the list aspect should be pulled up into Dependency?
+
 require "rubygems/version"
 require "rubygems/deprecate"
 
@@ -5,10 +15,6 @@ require "rubygems/deprecate"
 # load our yaml + workarounds now.
 Gem.load_yaml if defined? ::YAML
 
-##
-# A Requirement is a set of one or more version restrictions. It supports a
-# few (<tt>=, !=, >, <, >=, <=, ~></tt>) different restriction operators.
-
 class Gem::Requirement
   OPS = { #:nodoc:
     "="  =>  lambda { |v, r| v == r },
@@ -21,21 +27,11 @@ class Gem::Requirement
   }
 
   quoted  = OPS.keys.map { |k| Regexp.quote k }.join "|"
-  PATTERN_RAW = "\\s*(#{quoted})?\\s*(#{Gem::Version::VERSION_PATTERN})\\s*" # :nodoc:
-
-  ##
-  # A regular expression that matches a requirement
-
+  PATTERN_RAW = "\\s*(#{quoted})?\\s*(#{Gem::Version::VERSION_PATTERN})\\s*"
   PATTERN = /\A#{PATTERN_RAW}\z/
 
-  ##
-  # The default requirement matches any version
-
   DefaultRequirement = [">=", Gem::Version.new(0)]
 
-  ##
-  # Raised when a bad requirement is encountered
-
   class BadRequirementError < ArgumentError; end
 
   ##
@@ -45,6 +41,9 @@ class Gem::Requirement
   # If the input is "weird", the default version requirement is
   # returned.
 
+  # REFACTOR: There's no reason that this can't be unified with .new.
+  # .new is the standard Ruby factory method.
+
   def self.create input
     case input
     when Gem::Requirement then
@@ -79,6 +78,11 @@ class Gem::Requirement
   #     parse("1.0")                   # => ["=", "1.0"]
   #     parse(Gem::Version.new("1.0")) # => ["=,  "1.0"]
 
+  # REFACTOR: Little two element arrays like this have no real semantic
+  # value. I'd love to see something like this:
+  # Constraint = Struct.new(:operator, :version); (or similar)
+  # and have a Requirement be a list of Constraints.
+
   def self.parse obj
     return ["=", obj] if Gem::Version === obj
 
@@ -118,35 +122,9 @@ class Gem::Requirement
   end
 
   ##
-  # Concatenates the +new+ requirements onto this requirement.
-
-  def concat new
-    new = new.flatten
-    new.compact!
-    new.uniq!
-    new = new.map { |r| self.class.parse r }
-
-    @requirements.concat new
-  end
-
-  ##
-  # Formats this requirement for use in a Gem::RequestSet::Lockfile.
-
-  def for_lockfile # :nodoc:
-    return if [DefaultRequirement] == @requirements
-
-    list = requirements.sort_by { |_, version|
-      version
-    }.map { |op, version|
-      "#{op} #{version}"
-    }.uniq
-
-    " (#{list.join ', '})"
-  end
-
-  ##
   # true if this gem has no requirements.
 
+  # FIX: maybe this should be using #default ?
   def none?
     if @requirements.size == 1
       @requirements[0] == DefaultRequirement
@@ -155,14 +133,6 @@ class Gem::Requirement
     end
   end
 
-  ##
-  # true if the requirement is for only an exact version
-
-  def exact?
-    return false unless @requirements.size == 1
-    @requirements[0][0] == "="
-  end
-
   def as_list # :nodoc:
     requirements.map { |op, version| "#{op} #{version}" }.sort
   end
@@ -196,11 +166,11 @@ class Gem::Requirement
     yaml_initialize coder.tag, coder.map
   end
 
-  def to_yaml_properties # :nodoc:
+  def to_yaml_properties
     ["@requirements"]
   end
 
-  def encode_with coder # :nodoc:
+  def encode_with(coder)
     coder.add 'requirements', @requirements
   end
 
@@ -244,13 +214,15 @@ class Gem::Requirement
     as_list.join ", "
   end
 
-  def == other # :nodoc:
+  # DOC: this should probably be :nodoc'd
+  def == other
     Gem::Requirement === other and to_s == other.to_s
   end
 
   private
 
-  def fix_syck_default_key_in_requirements # :nodoc:
+  # DOC: this should probably be :nodoc'd
+  def fix_syck_default_key_in_requirements
     Gem.load_yaml
 
     # Fixup the Syck DefaultKey bug
@@ -262,9 +234,9 @@ class Gem::Requirement
   end
 end
 
-class Gem::Version
-  # This is needed for compatibility with older yaml
-  # gemspecs.
+# This is needed for compatibility with older yaml
+# gemspecs.
 
-  Requirement = Gem::Requirement # :nodoc:
+class Gem::Version
+  Requirement = Gem::Requirement
 end
diff --git a/lib/rubygems/resolver.rb b/lib/rubygems/resolver.rb
deleted file mode 100644
index 65e92bb..0000000
--- a/lib/rubygems/resolver.rb
+++ /dev/null
@@ -1,452 +0,0 @@
-require 'rubygems'
-require 'rubygems/dependency'
-require 'rubygems/exceptions'
-require 'rubygems/util/list'
-
-require 'uri'
-require 'net/http'
-
-##
-# Given a set of Gem::Dependency objects as +needed+ and a way to query the
-# set of available specs via +set+, calculates a set of ActivationRequest
-# objects which indicate all the specs that should be activated to meet the
-# all the requirements.
-
-class Gem::Resolver
-
-  ##
-  # If the DEBUG_RESOLVER environment variable is set then debugging mode is
-  # enabled for the resolver.  This will display information about the state
-  # of the resolver while a set of dependencies is being resolved.
-
-  DEBUG_RESOLVER = !ENV['DEBUG_RESOLVER'].nil?
-
-  ##
-  # Contains all the conflicts encountered while doing resolution
-
-  attr_reader :conflicts
-
-  ##
-  # Set to true if development dependencies should be considered.
-
-  attr_accessor :development
-
-  ##
-  # When true, no dependencies are looked up for requested gems.
-
-  attr_accessor :ignore_dependencies
-
-  ##
-  # List of dependencies that could not be found in the configured sources.
-
-  attr_reader :missing
-
-  attr_reader :stats
-
-  ##
-  # When a missing dependency, don't stop. Just go on and record what was
-  # missing.
-
-  attr_accessor :soft_missing
-
-  ##
-  # Combines +sets+ into a ComposedSet that allows specification lookup in a
-  # uniform manner.  If one of the +sets+ is itself a ComposedSet its sets are
-  # flattened into the result ComposedSet.
-
-  def self.compose_sets *sets
-    sets.compact!
-
-    sets = sets.map do |set|
-      case set
-      when Gem::Resolver::BestSet then
-        set
-      when Gem::Resolver::ComposedSet then
-        set.sets
-      else
-        set
-      end
-    end.flatten
-
-    case sets.length
-    when 0 then
-      raise ArgumentError, 'one set in the composition must be non-nil'
-    when 1 then
-      sets.first
-    else
-      Gem::Resolver::ComposedSet.new(*sets)
-    end
-  end
-
-  ##
-  # Creates a Resolver that queries only against the already installed gems
-  # for the +needed+ dependencies.
-
-  def self.for_current_gems needed
-    new needed, Gem::Resolver::CurrentSet.new
-  end
-
-  ##
-  # Create Resolver object which will resolve the tree starting
-  # with +needed+ Dependency objects.
-  #
-  # +set+ is an object that provides where to look for specifications to
-  # satisfy the Dependencies. This defaults to IndexSet, which will query
-  # rubygems.org.
-
-  def initialize needed, set = nil
-    @set = set || Gem::Resolver::IndexSet.new
-    @needed = needed
-
-    @conflicts           = []
-    @development         = false
-    @ignore_dependencies = false
-    @missing             = []
-    @soft_missing        = false
-    @stats               = Gem::Resolver::Stats.new
-  end
-
-  def explain stage, *data # :nodoc:
-    if DEBUG_RESOLVER
-      d = data.map { |x| x.inspect }.join(", ")
-      STDOUT.printf "%20s %s\n", stage.to_s.upcase, d
-    end
-  end
-
-  def explain_list stage, data # :nodoc:
-    if DEBUG_RESOLVER
-      STDOUT.printf "%20s (%d entries)\n", stage.to_s.upcase, data.size
-      data.each do |d|
-        STDOUT.printf "%20s %s\n", "", d
-      end
-    end
-  end
-
-  ##
-  # Creates an ActivationRequest for the given +dep+ and the last +possible+
-  # specification.
-  #
-  # Returns the Specification and the ActivationRequest
-
-  def activation_request dep, possible # :nodoc:
-    spec = possible.pop
-
-    explain :activate, [spec.full_name, possible.size]
-
-    activation_request =
-      Gem::Resolver::ActivationRequest.new spec, dep, possible
-
-    return spec, activation_request
-  end
-
-  def requests s, act, reqs=nil # :nodoc:
-    return reqs if @ignore_dependencies
-
-    s.dependencies.reverse_each do |d|
-      next if d.type == :development and not @development
-      reqs.add Gem::Resolver::DependencyRequest.new(d, act)
-      @stats.requirement!
-    end
-
-    @set.prefetch reqs
-
-    @stats.record_requirements reqs
-
-    reqs
-  end
-
-  ##
-  # Proceed with resolution! Returns an array of ActivationRequest objects.
-
-  def resolve
-    @conflicts = []
-
-    needed = Gem::Resolver::RequirementList.new
-
-    @needed.reverse_each do |n|
-      request = Gem::Resolver::DependencyRequest.new n, nil
-
-      needed.add request
-      @stats.requirement!
-    end
-
-    @stats.record_requirements needed
-
-    res = resolve_for needed, nil
-
-    raise Gem::DependencyResolutionError, res if
-      res.kind_of? Gem::Resolver::Conflict
-
-    res.to_a
-  end
-
-  ##
-  # Extracts the specifications that may be able to fulfill +dependency+ and
-  # returns those that match the local platform and all those that match.
-
-  def find_possible dependency # :nodoc:
-    all = @set.find_all dependency
-    matching_platform = select_local_platforms all
-
-    return matching_platform, all
-  end
-
-  def handle_conflict(dep, existing) # :nodoc:
-    # There is a conflict! We return the conflict object which will be seen by
-    # the caller and be handled at the right level.
-
-    # If the existing activation indicates that there are other possibles for
-    # it, then issue the conflict on the dependency for the activation itself.
-    # Otherwise, if there was a requester, issue it on the requester's
-    # request itself.
-    # Finally, if the existing request has no requester (toplevel) unwind to
-    # it anyway.
-
-    if existing.others_possible?
-      conflict =
-        Gem::Resolver::Conflict.new dep, existing
-    elsif dep.requester
-      depreq = dep.requester.request
-      conflict =
-        Gem::Resolver::Conflict.new depreq, existing, dep
-    elsif existing.request.requester.nil?
-      conflict =
-        Gem::Resolver::Conflict.new dep, existing
-    else
-      raise Gem::DependencyError, "Unable to figure out how to unwind conflict"
-    end
-
-    @conflicts << conflict unless @conflicts.include? conflict
-
-    return conflict
-  end
-
-  # Contains the state for attempting activation of a set of possible specs.
-  # +needed+ is a Gem::List of DependencyRequest objects that, well, need
-  # to be satisfied.
-  # +specs+ is the List of ActivationRequest that are being tested.
-  # +dep+ is the DependencyRequest that was used to generate this state.
-  # +spec+ is the Specification for this state.
-  # +possible+ is List of DependencyRequest objects that can be tried to
-  # find a  complete set.
-  # +conflicts+ is a [DependencyRequest, Conflict] hit tried to
-  # activate the state.
-  #
-  State = Struct.new(:needed, :specs, :dep, :spec, :possibles, :conflicts) do
-    def summary # :nodoc:
-      nd = needed.map { |s| s.to_s }.sort if nd
-
-      if specs then
-        ss = specs.map { |s| s.full_name }.sort
-        ss.unshift ss.length
-      end
-
-      d = dep.to_s
-      d << " from #{dep.requester.full_name}" if dep.requester
-
-      ps = possibles.map { |p| p.full_name }.sort
-      ps.unshift ps.length
-
-      cs = conflicts.map do |(s, c)|
-        [s.full_name, c.conflicting_dependencies.map { |cd| cd.to_s }]
-      end
-
-      { :needed => nd, :specs => ss, :dep => d, :spec => spec.full_name,
-        :possibles => ps, :conflicts => cs }
-    end
-  end
-
-  ##
-  # The meat of the algorithm. Given +needed+ DependencyRequest objects and
-  # +specs+ being a list to ActivationRequest, calculate a new list of
-  # ActivationRequest objects.
-
-  def resolve_for needed, specs # :nodoc:
-    # The State objects that are used to attempt the activation tree.
-    states = []
-
-    while !needed.empty?
-      @stats.iteration!
-
-      dep = needed.remove
-      explain :try, [dep, dep.requester ? dep.requester.request : :toplevel]
-      explain_list :next5, needed.next5
-      explain_list :specs, Array(specs).map { |x| x.full_name }.sort
-
-      # If there is already a spec activated for the requested name...
-      if specs && existing = specs.find { |s| dep.name == s.name }
-        # then we're done since this new dep matches the existing spec.
-        next if dep.matches_spec? existing
-
-        conflict = handle_conflict dep, existing
-
-        return conflict unless dep.requester
-
-        explain :conflict, dep, :existing, existing.full_name
-
-        depreq = dep.requester.request
-
-        state = nil
-        until states.empty?
-          x = states.pop
-
-          i = existing.request.requester
-          explain :consider, x.spec.full_name, [depreq.name, dep.name, i ? i.name : :top]
-
-          if x.spec.name == depreq.name or
-              x.spec.name == dep.name or
-              (i && (i.name == x.spec.name))
-            explain :found, x.spec.full_name
-            state = x
-            break
-          end
-        end
-
-        return conflict unless state
-
-        @stats.backtracking!
-
-        needed, specs = resolve_for_conflict needed, specs, state
-
-        states << state unless state.possibles.empty?
-
-        next
-      end
-
-      matching, all = find_possible dep
-
-      case matching.size
-      when 0
-        resolve_for_zero dep, all
-      when 1
-        needed, specs =
-          resolve_for_single needed, specs, dep, matching
-      else
-        needed, specs =
-          resolve_for_multiple needed, specs, states, dep, matching
-      end
-    end
-
-    specs
-  end
-
-  ##
-  # Rewinds +needed+ and +specs+ to a previous state in +state+ for a conflict
-  # between +dep+ and +existing+.
-
-  def resolve_for_conflict needed, specs, state # :nodoc:
-    # We exhausted the possibles so it's definitely not going to work out,
-    # bail out.
-    raise Gem::ImpossibleDependenciesError.new state.dep, state.conflicts if
-      state.possibles.empty?
-
-    # Retry resolution with this spec and add it's dependencies
-    spec, act = activation_request state.dep, state.possibles
-
-    needed = requests spec, act, state.needed.dup
-    specs = Gem::List.prepend state.specs, act
-
-    return needed, specs
-  end
-
-  ##
-  # There are multiple +possible+ specifications for this +dep+.  Updates
-  # +needed+, +specs+ and +states+ for further resolution of the +possible+
-  # choices.
-
-  def resolve_for_multiple needed, specs, states, dep, possible # :nodoc:
-    # Sort them so that we try the highest versions first.
-    possible = possible.sort_by do |s|
-      [s.source, s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
-    end
-
-    spec, act = activation_request dep, possible
-
-    # We may need to try all of +possible+, so we setup state to unwind back
-    # to current +needed+ and +specs+ so we can try another. This is code is
-    # what makes conflict resolution possible.
-    states << State.new(needed.dup, specs, dep, spec, possible, [])
-
-    @stats.record_depth states
-
-    explain :states, states.map { |s| s.dep }
-
-    needed = requests spec, act, needed
-    specs = Gem::List.prepend specs, act
-
-    return needed, specs
-  end
-
-  ##
-  # Add the spec from the +possible+ list to +specs+ and process the spec's
-  # dependencies by adding them to +needed+.
-
-  def resolve_for_single needed, specs, dep, possible # :nodoc:
-    spec, act = activation_request dep, possible
-
-    specs = Gem::List.prepend specs, act
-
-    # Put the deps for at the beginning of needed
-    # rather than the end to match the depth first
-    # searching done by the multiple case code below.
-    #
-    # This keeps the error messages consistent.
-    needed = requests spec, act, needed
-
-    return needed, specs
-  end
-
-  ##
-  # When there are no possible specifications for +dep+ our work is done.
-
-  def resolve_for_zero dep, platform_mismatch # :nodoc:
-    @missing << dep
-
-    unless @soft_missing
-      raise Gem::UnsatisfiableDependencyError.new(dep, platform_mismatch)
-    end
-  end
-
-  ##
-  # Returns the gems in +specs+ that match the local platform.
-
-  def select_local_platforms specs # :nodoc:
-    specs.select do |spec|
-      Gem::Platform.installable? spec
-    end
-  end
-
-end
-
-##
-# TODO remove in RubyGems 3
-
-Gem::DependencyResolver = Gem::Resolver # :nodoc:
-
-require 'rubygems/resolver/activation_request'
-require 'rubygems/resolver/conflict'
-require 'rubygems/resolver/dependency_request'
-require 'rubygems/resolver/requirement_list'
-require 'rubygems/resolver/stats'
-
-require 'rubygems/resolver/set'
-require 'rubygems/resolver/api_set'
-require 'rubygems/resolver/composed_set'
-require 'rubygems/resolver/best_set'
-require 'rubygems/resolver/current_set'
-require 'rubygems/resolver/git_set'
-require 'rubygems/resolver/index_set'
-require 'rubygems/resolver/installer_set'
-require 'rubygems/resolver/lock_set'
-require 'rubygems/resolver/vendor_set'
-
-require 'rubygems/resolver/specification'
-require 'rubygems/resolver/spec_specification'
-require 'rubygems/resolver/api_specification'
-require 'rubygems/resolver/git_specification'
-require 'rubygems/resolver/index_specification'
-require 'rubygems/resolver/installed_specification'
-require 'rubygems/resolver/local_specification'
-require 'rubygems/resolver/lock_specification'
-require 'rubygems/resolver/vendor_specification'
-
diff --git a/lib/rubygems/resolver/activation_request.rb b/lib/rubygems/resolver/activation_request.rb
deleted file mode 100644
index 2d48cfa..0000000
--- a/lib/rubygems/resolver/activation_request.rb
+++ /dev/null
@@ -1,165 +0,0 @@
-##
-# Specifies a Specification object that should be activated.  Also contains a
-# dependency that was used to introduce this activation.
-
-class Gem::Resolver::ActivationRequest
-
-  ##
-  # The parent request for this activation request.
-
-  attr_reader :request
-
-  ##
-  # The specification to be activated.
-
-  attr_reader :spec
-
-  ##
-  # Creates a new ActivationRequest that will activate +spec+.  The parent
-  # +request+ is used to provide diagnostics in case of conflicts.
-  #
-  # +others_possible+ indicates that other specifications may also match this
-  # activation request.
-
-  def initialize spec, request, others_possible = true
-    @spec = spec
-    @request = request
-    @others_possible = others_possible
-  end
-
-  def == other # :nodoc:
-    case other
-    when Gem::Specification
-      @spec == other
-    when Gem::Resolver::ActivationRequest
-      @spec == other.spec && @request == other.request
-    else
-      false
-    end
-  end
-
-  ##
-  # Downloads a gem at +path+ and returns the file path.
-
-  def download path
-    if @spec.respond_to? :source
-      source = @spec.source
-    else
-      source = Gem.sources.first
-    end
-
-    Gem.ensure_gem_subdirectories path
-
-    source.download full_spec, path
-  end
-
-  ##
-  # The full name of the specification to be activated.
-
-  def full_name
-    @spec.full_name
-  end
-
-  ##
-  # The Gem::Specification for this activation request.
-
-  def full_spec
-    Gem::Specification === @spec ? @spec : @spec.spec
-  end
-
-  def inspect # :nodoc:
-    others =
-      case @others_possible
-      when true then # TODO remove at RubyGems 3
-        ' (others possible)'
-      when false then # TODO remove at RubyGems 3
-        nil
-      else
-        unless @others_possible.empty? then
-          others = @others_possible.map { |s| s.full_name }
-          " (others possible: #{others.join ', '})"
-        end
-      end
-
-    '#<%s for %p from %s%s>' % [
-      self.class, @spec, @request, others
-    ]
-  end
-
-  ##
-  # True if the requested gem has already been installed.
-
-  def installed?
-    case @spec
-    when Gem::Resolver::VendorSpecification then
-      true
-    else
-      this_spec = full_spec
-
-      Gem::Specification.any? do |s|
-        s == this_spec
-      end
-    end
-  end
-
-  ##
-  # The name of this activation request's specification
-
-  def name
-    @spec.name
-  end
-
-  ##
-  # Indicate if this activation is one of a set of possible
-  # requests for the same Dependency request.
-
-  def others_possible?
-    case @others_possible
-    when true, false then
-      @others_possible
-    else
-      not @others_possible.empty?
-    end
-  end
-
-  ##
-  # Return the ActivationRequest that contained the dependency
-  # that we were activated for.
-
-  def parent
-    @request.requester
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Activation request', ']' do
-      q.breakable
-      q.pp @spec
-
-      q.breakable
-      q.text ' for '
-      q.pp @request
-
-      case @others_possible
-      when false then
-      when true then
-        q.breakable
-        q.text 'others possible'
-      else
-        unless @others_possible.empty? then
-          q.breakable
-          q.text 'others '
-          q.pp @others_possible.map { |s| s.full_name }
-        end
-      end
-    end
-  end
-
-  ##
-  # The version of this activation request's specification
-
-  def version
-    @spec.version
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/api_set.rb b/lib/rubygems/resolver/api_set.rb
deleted file mode 100644
index 5475e62..0000000
--- a/lib/rubygems/resolver/api_set.rb
+++ /dev/null
@@ -1,115 +0,0 @@
-##
-# The global rubygems pool, available via the rubygems.org API.
-# Returns instances of APISpecification.
-
-class Gem::Resolver::APISet < Gem::Resolver::Set
-
-  ##
-  # The URI for the dependency API this APISet uses.
-
-  attr_reader :dep_uri # :nodoc:
-
-  ##
-  # The Gem::Source that gems are fetched from
-
-  attr_reader :source
-
-  ##
-  # The corresponding place to fetch gems.
-
-  attr_reader :uri
-
-  ##
-  # Creates a new APISet that will retrieve gems from +uri+ using the RubyGems
-  # API URL +dep_uri+ which is described at
-  # http://guides.rubygems.org/rubygems-org-api
-
-  def initialize dep_uri = 'https://rubygems.org/api/v1/dependencies'
-    super()
-
-    dep_uri = URI dep_uri unless URI === dep_uri # for ruby 1.8
-
-    @dep_uri = dep_uri
-    @uri     = dep_uri + '../..'
-
-    @data   = Hash.new { |h,k| h[k] = [] }
-    @source = Gem::Source.new @uri
-  end
-
-  ##
-  # Return an array of APISpecification objects matching
-  # DependencyRequest +req+.
-
-  def find_all req
-    res = []
-
-    return res unless @remote
-
-    versions(req.name).each do |ver|
-      if req.dependency.match? req.name, ver[:number]
-        res << Gem::Resolver::APISpecification.new(self, ver)
-      end
-    end
-
-    res
-  end
-
-  ##
-  # A hint run by the resolver to allow the Set to fetch
-  # data for DependencyRequests +reqs+.
-
-  def prefetch reqs
-    return unless @remote
-    names = reqs.map { |r| r.dependency.name }
-    needed = names - @data.keys
-
-    return if needed.empty?
-
-    uri = @dep_uri + "?gems=#{needed.sort.join ','}"
-    str = Gem::RemoteFetcher.fetcher.fetch_path uri
-
-    loaded = []
-
-    Marshal.load(str).each do |ver|
-      name = ver[:name]
-
-      @data[name] << ver
-      loaded << name
-    end
-
-    (needed - loaded).each do |missing|
-      @data[missing] = []
-    end
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[APISet', ']' do
-      q.breakable
-      q.text "URI: #{@dep_uri}"
-
-      q.breakable
-      q.text 'gem names:'
-      q.pp @data.keys
-    end
-  end
-
-  ##
-  # Return data for all versions of the gem +name+.
-
-  def versions name # :nodoc:
-    if @data.key?(name)
-      return @data[name]
-    end
-
-    uri = @dep_uri + "?gems=#{name}"
-    str = Gem::RemoteFetcher.fetcher.fetch_path uri
-
-    Marshal.load(str).each do |ver|
-      @data[ver[:name]] << ver
-    end
-
-    @data[name]
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/api_specification.rb b/lib/rubygems/resolver/api_specification.rb
deleted file mode 100644
index 67052af..0000000
--- a/lib/rubygems/resolver/api_specification.rb
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-# Represents a specification retrieved via the rubygems.org API.
-#
-# This is used to avoid loading the full Specification object when all we need
-# is the name, version, and dependencies.
-
-class Gem::Resolver::APISpecification < Gem::Resolver::Specification
-
-  ##
-  # Creates an APISpecification for the given +set+ from the rubygems.org
-  # +api_data+.
-  #
-  # See http://guides.rubygems.org/rubygems-org-api/#misc_methods for the
-  # format of the +api_data+.
-
-  def initialize(set, api_data)
-    super()
-
-    @set = set
-    @name = api_data[:name]
-    @version = Gem::Version.new api_data[:number]
-    @platform = api_data[:platform]
-    @dependencies = api_data[:dependencies].map do |name, ver|
-      Gem::Dependency.new name, ver.split(/\s*,\s*/)
-    end
-  end
-
-  def == other # :nodoc:
-    self.class === other and
-      @set          == other.set and
-      @name         == other.name and
-      @version      == other.version and
-      @platform     == other.platform and
-      @dependencies == other.dependencies
-  end
-
-  def installable_platform? # :nodoc:
-    Gem::Platform.match @platform
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[APISpecification', ']' do
-      q.breakable
-      q.text "name: #{name}"
-
-      q.breakable
-      q.text "version: #{version}"
-
-      q.breakable
-      q.text "platform: #{platform}"
-
-      q.breakable
-      q.text 'dependencies:'
-      q.breakable
-      q.pp @dependencies
-
-      q.breakable
-      q.text "set uri: #{@set.dep_uri}"
-    end
-  end
-
-  ##
-  # Fetches a Gem::Specification for this APISpecification.
-
-  def spec # :nodoc:
-    @spec ||=
-      begin
-        tuple = Gem::NameTuple.new @name, @version, @platform
-
-        source.fetch_spec tuple
-      end
-  end
-
-  def source # :nodoc:
-    @set.source
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/best_set.rb b/lib/rubygems/resolver/best_set.rb
deleted file mode 100644
index 20bb948..0000000
--- a/lib/rubygems/resolver/best_set.rb
+++ /dev/null
@@ -1,50 +0,0 @@
-##
-# The BestSet chooses the best available method to query a remote index.
-#
-# It combines IndexSet and APISet
-
-class Gem::Resolver::BestSet < Gem::Resolver::ComposedSet
-
-  ##
-  # Creates a BestSet for the given +sources+ or Gem::sources if none are
-  # specified.  +sources+ must be a Gem::SourceList.
-
-  def initialize sources = Gem.sources
-    super()
-
-    @sources = sources
-  end
-
-  ##
-  # Picks which sets to use for the configured sources.
-
-  def pick_sets # :nodoc:
-    @sources.each_source do |source|
-      @sets << source.dependency_resolver_set
-    end
-  end
-
-  def find_all req # :nodoc:
-    pick_sets if @remote and @sets.empty?
-
-    super
-  end
-
-  def prefetch reqs # :nodoc:
-    pick_sets if @remote and @sets.empty?
-
-    super
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[BestSet', ']' do
-      q.breakable
-      q.text 'sets:'
-
-      q.breakable
-      q.pp @sets
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/composed_set.rb b/lib/rubygems/resolver/composed_set.rb
deleted file mode 100644
index 6f912b0..0000000
--- a/lib/rubygems/resolver/composed_set.rb
+++ /dev/null
@@ -1,50 +0,0 @@
-##
-# A ComposedSet allows multiple sets to be queried like a single set.
-#
-# To create a composed set with any number of sets use:
-#
-#   Gem::Resolver.compose_sets set1, set2
-#
-# This method will eliminate nesting of composed sets.
-
-class Gem::Resolver::ComposedSet < Gem::Resolver::Set
-
-  attr_reader :sets # :nodoc:
-
-  ##
-  # Creates a new ComposedSet containing +sets+.  Use
-  # Gem::Resolver::compose_sets instead.
-
-  def initialize *sets
-    super()
-
-    @sets = sets
-  end
-
-  ##
-  # Sets the remote network access for all composed sets.
-
-  def remote= remote
-    super
-
-    @sets.each { |set| set.remote = remote }
-  end
-
-  ##
-  # Finds all specs matching +req+ in all sets.
-
-  def find_all req
-    @sets.map do |s|
-      s.find_all req
-    end.flatten
-  end
-
-  ##
-  # Prefetches +reqs+ in all sets.
-
-  def prefetch reqs
-    @sets.each { |s| s.prefetch(reqs) }
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/conflict.rb b/lib/rubygems/resolver/conflict.rb
deleted file mode 100644
index 8830e8d..0000000
--- a/lib/rubygems/resolver/conflict.rb
+++ /dev/null
@@ -1,122 +0,0 @@
-##
-# Used internally to indicate that a dependency conflicted
-# with a spec that would be activated.
-
-class Gem::Resolver::Conflict
-
-  ##
-  # The specification that was activated prior to the conflict
-
-  attr_reader :activated
-
-  ##
-  # The dependency that is in conflict with the activated gem.
-
-  attr_reader :dependency
-
-  attr_reader :failed_dep # :nodoc:
-
-  ##
-  # Creates a new resolver conflict when +dependency+ is in conflict with an
-  # already +activated+ specification.
-
-  def initialize(dependency, activated, failed_dep=dependency)
-    @dependency = dependency
-    @activated = activated
-    @failed_dep = failed_dep
-  end
-
-  def == other # :nodoc:
-    self.class === other and
-      @dependency == other.dependency and
-      @activated  == other.activated  and
-      @failed_dep == other.failed_dep
-  end
-
-  ##
-  # A string explanation of the conflict.
-
-  def explain
-    "<Conflict wanted: #{@failed_dep}, had: #{activated.spec.full_name}>"
-  end
-
-  ##
-  # Return the 2 dependency objects that conflicted
-
-  def conflicting_dependencies
-    [@failed_dep.dependency, @activated.request.dependency]
-  end
-
-  ##
-  # Explanation of the conflict used by exceptions to print useful messages
-
-  def explanation
-    activated   = @activated.spec.full_name
-    requirement = @failed_dep.dependency.requirement
-
-    "  Activated %s via:\n    %s\n  instead of (%s) via:\n    %s\n" % [
-      activated,   request_path(@activated).join(', '),
-      requirement, request_path(requester).join(', '),
-    ]
-  end
-
-  ##
-  # Returns true if the conflicting dependency's name matches +spec+.
-
-  def for_spec?(spec)
-    @dependency.name == spec.name
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Dependency conflict: ', ']' do
-      q.breakable
-
-      q.text 'activated '
-      q.pp @activated
-
-      q.breakable
-      q.text ' dependency '
-      q.pp @dependency
-
-      q.breakable
-      if @dependency == @failed_dep then
-        q.text ' failed'
-      else
-        q.text ' failed dependency '
-        q.pp @failed_dep
-      end
-    end
-  end
-
-  ##
-  # Path of activations from the +current+ list.
-
-  def request_path current
-    path = []
-
-    while current do
-      requirement = current.request.dependency.requirement
-      path << "#{current.spec.full_name} (#{requirement})"
-
-      current = current.parent
-    end
-
-    path = ['user request (gem command or Gemfile)'] if path.empty?
-
-    path
-  end
-
-  ##
-  # Return the Specification that listed the dependency
-
-  def requester
-    @failed_dep.requester
-  end
-
-end
-
-##
-# TODO: Remove in RubyGems 3
-
-Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict # :nodoc:
-
diff --git a/lib/rubygems/resolver/current_set.rb b/lib/rubygems/resolver/current_set.rb
deleted file mode 100644
index 4e8d340..0000000
--- a/lib/rubygems/resolver/current_set.rb
+++ /dev/null
@@ -1,13 +0,0 @@
-##
-# A set which represents the installed gems. Respects
-# all the normal settings that control where to look
-# for installed gems.
-
-class Gem::Resolver::CurrentSet < Gem::Resolver::Set
-
-  def find_all req
-    req.dependency.matching_specs
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/dependency_request.rb b/lib/rubygems/resolver/dependency_request.rb
deleted file mode 100644
index 1d51db4..0000000
--- a/lib/rubygems/resolver/dependency_request.rb
+++ /dev/null
@@ -1,97 +0,0 @@
-##
-# Used Internally. Wraps a Dependency object to also track which spec
-# contained the Dependency.
-
-class Gem::Resolver::DependencyRequest
-
-  ##
-  # The wrapped Gem::Dependency
-
-  attr_reader :dependency
-
-  ##
-  # The request for this dependency.
-
-  attr_reader :requester
-
-  ##
-  # Creates a new DependencyRequest for +dependency+ from +requester+.
-  # +requester may be nil if the request came from a user.
-
-  def initialize dependency, requester
-    @dependency = dependency
-    @requester  = requester
-  end
-
-  def == other # :nodoc:
-    case other
-    when Gem::Dependency
-      @dependency == other
-    when Gem::Resolver::DependencyRequest
-      @dependency == other.dependency && @requester == other.requester
-    else
-      false
-    end
-  end
-
-  ##
-  # Does this dependency request match +spec+
-
-  def matches_spec?(spec)
-    @dependency.matches_spec? spec
-  end
-
-  ##
-  # The name of the gem this dependency request is requesting.
-
-  def name
-    @dependency.name
-  end
-
-  ##
-  # Indicate that the request is for a gem explicitly requested by the user
-
-  def explicit?
-    @requester.nil?
-  end
-
-  ##
-  # Indicate that the request is for a gem requested as a dependency of
-  # another gem
-
-  def implicit?
-    !explicit?
-  end
-
-  ##
-  # Return a String indicating who caused this request to be added (only
-  # valid for implicit requests)
-
-  def request_context
-    @requester ? @requester.request : "(unknown)"
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Dependency request ', ']' do
-      q.breakable
-      q.text @dependency.to_s
-
-      q.breakable
-      q.text ' requested by '
-      q.pp @requester
-    end
-  end
-
-  ##
-  # The version requirement for this dependency request
-
-  def requirement
-    @dependency.requirement
-  end
-
-  def to_s # :nodoc:
-    @dependency.to_s
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/git_set.rb b/lib/rubygems/resolver/git_set.rb
deleted file mode 100644
index d32710e..0000000
--- a/lib/rubygems/resolver/git_set.rb
+++ /dev/null
@@ -1,122 +0,0 @@
-##
-# A GitSet represents gems that are sourced from git repositories.
-#
-# This is used for gem dependency file support.
-#
-# Example:
-#
-#   set = Gem::Resolver::GitSet.new
-#   set.add_git_gem 'rake', 'git://example/rake.git', tag: 'rake-10.1.0'
-
-class Gem::Resolver::GitSet < Gem::Resolver::Set
-
-  ##
-  # The root directory for git gems in this set.  This is usually Gem.dir, the
-  # installation directory for regular gems.
-
-  attr_accessor :root_dir
-
-  ##
-  # Contains repositories needing submodules
-
-  attr_reader :need_submodules # :nodoc:
-
-  ##
-  # A Hash containing git gem names for keys and a Hash of repository and
-  # git commit reference as values.
-
-  attr_reader :repositories # :nodoc:
-
-  ##
-  # A hash of gem names to Gem::Resolver::GitSpecifications
-
-  attr_reader :specs # :nodoc:
-
-  def initialize # :nodoc:
-    super()
-
-    @git             = ENV['git'] || 'git'
-    @need_submodules = {}
-    @repositories    = {}
-    @root_dir        = Gem.dir
-    @specs           = {}
-  end
-
-  def add_git_gem name, repository, reference, submodules # :nodoc:
-    @repositories[name] = [repository, reference]
-    @need_submodules[repository] = submodules
-  end
-
-  ##
-  # Adds and returns a GitSpecification with the given +name+ and +version+
-  # which came from a +repository+ at the given +reference+.  If +submodules+
-  # is true they are checked out along with the repository.
-  #
-  # This fills in the prefetch information as enough information about the gem
-  # is present in the arguments.
-
-  def add_git_spec name, version, repository, reference, submodules # :nodoc:
-    add_git_gem name, repository, reference, submodules
-
-    source = Gem::Source::Git.new name, repository, reference
-    source.root_dir = @root_dir
-
-    spec = Gem::Specification.new do |s|
-      s.name    = name
-      s.version = version
-    end
-
-    git_spec = Gem::Resolver::GitSpecification.new self, spec, source
-
-    @specs[spec.name] = git_spec
-
-    git_spec
-  end
-
-  ##
-  # Finds all git gems matching +req+
-
-  def find_all req
-    prefetch nil
-
-    specs.values.select do |spec|
-      req.matches_spec? spec
-    end
-  end
-
-  ##
-  # Prefetches specifications from the git repositories in this set.
-
-  def prefetch reqs
-    return unless @specs.empty?
-
-    @repositories.each do |name, (repository, reference)|
-      source = Gem::Source::Git.new name, repository, reference
-      source.root_dir = @root_dir
-      source.remote = @remote
-
-      source.specs.each do |spec|
-        git_spec = Gem::Resolver::GitSpecification.new self, spec, source
-
-        @specs[spec.name] = git_spec
-      end
-    end
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[GitSet', ']' do
-      next if @repositories.empty?
-      q.breakable
-
-      repos = @repositories.map do |name, (repository, reference)|
-        "#{name}: #{repository}@#{reference}"
-      end
-
-      q.seplist repos do |repo|
-        q.text repo
-      end
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/git_specification.rb b/lib/rubygems/resolver/git_specification.rb
deleted file mode 100644
index 113e7ea..0000000
--- a/lib/rubygems/resolver/git_specification.rb
+++ /dev/null
@@ -1,35 +0,0 @@
-##
-# A GitSpecification represents a gem that is sourced from a git repository
-# and is being loaded through a gem dependencies file through the +git:+
-# option.
-
-class Gem::Resolver::GitSpecification < Gem::Resolver::SpecSpecification
-
-  def == other # :nodoc:
-    self.class === other and
-      @set  == other.set and
-      @spec == other.spec and
-      @source == other.source
-  end
-
-  ##
-  # Installing a git gem only involves building the extensions and generating
-  # the executables.
-
-  def install options
-    require 'rubygems/installer'
-
-    installer = Gem::Installer.new '', options
-    installer.spec = spec
-
-    yield installer if block_given?
-
-    installer.run_pre_install_hooks
-    installer.build_extensions
-    installer.run_post_build_hooks
-    installer.generate_bin
-    installer.run_post_install_hooks
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/index_set.rb b/lib/rubygems/resolver/index_set.rb
deleted file mode 100644
index ef01f0f..0000000
--- a/lib/rubygems/resolver/index_set.rb
+++ /dev/null
@@ -1,78 +0,0 @@
-##
-# The global rubygems pool represented via the traditional
-# source index.
-
-class Gem::Resolver::IndexSet < Gem::Resolver::Set
-
-  def initialize source = nil # :nodoc:
-    super()
-
-    @f =
-      if source then
-        sources = Gem::SourceList.from [source]
-
-        Gem::SpecFetcher.new sources
-      else
-        Gem::SpecFetcher.fetcher
-      end
-
-    @all = Hash.new { |h,k| h[k] = [] }
-
-    list, = @f.available_specs :released
-
-    list.each do |uri, specs|
-      specs.each do |n|
-        @all[n.name] << [uri, n]
-      end
-    end
-
-    @specs = {}
-  end
-
-  ##
-  # Return an array of IndexSpecification objects matching
-  # DependencyRequest +req+.
-
-  def find_all req
-    res = []
-
-    return res unless @remote
-
-    name = req.dependency.name
-
-    @all[name].each do |uri, n|
-      if req.dependency.match? n then
-        res << Gem::Resolver::IndexSpecification.new(
-          self, n.name, n.version, uri, n.platform)
-      end
-    end
-
-    res
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[IndexSet', ']' do
-      q.breakable
-      q.text 'sources:'
-      q.breakable
-      q.pp @f.sources
-
-      q.breakable
-      q.text 'specs:'
-
-      q.breakable
-
-      names = @all.values.map do |tuples|
-        tuples.map do |_, tuple|
-          tuple.full_name
-        end
-      end.flatten
-
-      q.seplist names do |name|
-        q.text name
-      end
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/index_specification.rb b/lib/rubygems/resolver/index_specification.rb
deleted file mode 100644
index 56fecb5..0000000
--- a/lib/rubygems/resolver/index_specification.rb
+++ /dev/null
@@ -1,69 +0,0 @@
-##
-# Represents a possible Specification object returned from IndexSet.  Used to
-# delay needed to download full Specification objects when only the +name+
-# and +version+ are needed.
-
-class Gem::Resolver::IndexSpecification < Gem::Resolver::Specification
-
-  ##
-  # An IndexSpecification is created from the index format described in `gem
-  # help generate_index`.
-  #
-  # The +set+ contains other specifications for this (URL) +source+.
-  #
-  # The +name+, +version+ and +platform+ are the name, version and platform of
-  # the gem.
-
-  def initialize set, name, version, source, platform
-    super()
-
-    @set = set
-    @name = name
-    @version = version
-    @source = source
-    @platform = platform.to_s
-
-    @spec = nil
-  end
-
-  ##
-  # The dependencies of the gem for this specification
-
-  def dependencies
-    spec.dependencies
-  end
-
-  def inspect # :nodoc:
-    '#<%s %s source %s>' % [self.class, full_name, @source]
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Index specification', ']' do
-      q.breakable
-      q.text full_name
-
-      unless Gem::Platform::RUBY == @platform then
-        q.breakable
-        q.text @platform.to_s
-      end
-
-      q.breakable
-      q.text 'source '
-      q.pp @source
-    end
-  end
-
-  ##
-  # Fetches a Gem::Specification for this IndexSpecification from the #source.
-
-  def spec # :nodoc:
-    @spec ||=
-      begin
-        tuple = Gem::NameTuple.new @name, @version, @platform
-
-        @source.fetch_spec tuple
-      end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/installed_specification.rb b/lib/rubygems/resolver/installed_specification.rb
deleted file mode 100644
index a943812..0000000
--- a/lib/rubygems/resolver/installed_specification.rb
+++ /dev/null
@@ -1,40 +0,0 @@
-##
-# An InstalledSpecification represents a gem that is already installed
-# locally.
-
-class Gem::Resolver::InstalledSpecification < Gem::Resolver::SpecSpecification
-
-  def == other # :nodoc:
-    self.class === other and
-      @set  == other.set and
-      @spec == other.spec
-  end
-
-  ##
-  # This is a null install as this specification is already installed.
-  # +options+ are ignored.
-
-  def install options
-    yield nil
-  end
-
-  ##
-  # Returns +true+ if this gem is installable for the current platform.
-
-  def installable_platform?
-    # BACKCOMPAT If the file is coming out of a specified file, then we
-    # ignore the platform. This code can be removed in RG 3.0.
-    return true if @source.kind_of? Gem::Source::SpecificFile
-
-    super
-  end
-
-  ##
-  # The source for this specification
-
-  def source
-    @source ||= Gem::Source::Installed.new
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/installer_set.rb b/lib/rubygems/resolver/installer_set.rb
deleted file mode 100644
index 045c893..0000000
--- a/lib/rubygems/resolver/installer_set.rb
+++ /dev/null
@@ -1,138 +0,0 @@
-##
-# A set of gems for installation sourced from remote sources and local .gem
-# files
-
-class Gem::Resolver::InstallerSet < Gem::Resolver::Set
-
-  ##
-  # List of Gem::Specification objects that must always be installed.
-
-  attr_reader :always_install # :nodoc:
-
-  ##
-  # Only install gems in the always_install list
-
-  attr_accessor :ignore_dependencies # :nodoc:
-
-  ##
-  # Do not look in the installed set when finding specifications.  This is
-  # used by the --install-dir option to `gem install`
-
-  attr_accessor :ignore_installed # :nodoc:
-
-  ##
-  # Creates a new InstallerSet that will look for gems in +domain+.
-
-  def initialize domain
-    super()
-
-    @domain = domain
-    @remote = consider_remote?
-
-    @f = Gem::SpecFetcher.fetcher
-
-    @always_install      = []
-    @ignore_dependencies = false
-    @ignore_installed    = false
-    @remote_set          = Gem::Resolver::BestSet.new
-    @specs               = {}
-  end
-
-  ##
-  # Should local gems should be considered?
-
-  def consider_local? # :nodoc:
-    @domain == :both or @domain == :local
-  end
-
-  ##
-  # Should remote gems should be considered?
-
-  def consider_remote? # :nodoc:
-    @domain == :both or @domain == :remote
-  end
-
-  ##
-  # Returns an array of IndexSpecification objects matching DependencyRequest
-  # +req+.
-
-  def find_all req
-    res = []
-
-    dep  = req.dependency
-
-    return res if @ignore_dependencies and
-              @always_install.none? { |spec| dep.matches_spec? spec }
-
-    name = dep.name
-
-    dep.matching_specs.each do |gemspec|
-      next if @always_install.include? gemspec
-
-      res << Gem::Resolver::InstalledSpecification.new(self, gemspec)
-    end unless @ignore_installed
-
-    if consider_local? then
-      local_source = Gem::Source::Local.new
-
-      if spec = local_source.find_gem(name, dep.requirement) then
-        res << Gem::Resolver::IndexSpecification.new(
-          self, spec.name, spec.version, local_source, spec.platform)
-      end
-    end
-
-    res.concat @remote_set.find_all req if consider_remote?
-
-    res
-  end
-
-  def inspect # :nodoc:
-    always_install = @always_install.map { |s| s.full_name }
-
-    '#<%s domain: %s specs: %p always install: %p>' % [
-      self.class, @domain, @specs.keys, always_install,
-    ]
-  end
-
-  ##
-  # Called from IndexSpecification to get a true Specification
-  # object.
-
-  def load_spec name, ver, platform, source # :nodoc:
-    key = "#{name}-#{ver}-#{platform}"
-
-    @specs.fetch key do
-      tuple = Gem::NameTuple.new name, ver, platform
-
-      @specs[key] = source.fetch_spec tuple
-    end
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[InstallerSet', ']' do
-      q.breakable
-      q.text "domain: #{@domain}"
-
-      q.breakable
-      q.text 'specs: '
-      q.pp @specs.keys
-
-      q.breakable
-      q.text 'always install: '
-      q.pp @always_install
-    end
-  end
-
-  def remote= remote # :nodoc:
-    case @domain
-    when :local then
-      @domain = :both if remote
-    when :remote then
-      @domain = nil unless remote
-    when :both then
-      @domain = :local unless remote
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/local_specification.rb b/lib/rubygems/resolver/local_specification.rb
deleted file mode 100644
index dcca6c7..0000000
--- a/lib/rubygems/resolver/local_specification.rb
+++ /dev/null
@@ -1,16 +0,0 @@
-##
-# A LocalSpecification comes from a .gem file on the local filesystem.
-
-class Gem::Resolver::LocalSpecification < Gem::Resolver::SpecSpecification
-
-  ##
-  # Returns +true+ if this gem is installable for the current platform.
-
-  def installable_platform?
-    return true if @source.kind_of? Gem::Source::SpecificFile
-
-    super
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/lock_set.rb b/lib/rubygems/resolver/lock_set.rb
deleted file mode 100644
index f498757..0000000
--- a/lib/rubygems/resolver/lock_set.rb
+++ /dev/null
@@ -1,80 +0,0 @@
-##
-# A set of gems from a gem dependencies lockfile.
-
-class Gem::Resolver::LockSet < Gem::Resolver::Set
-
-  attr_reader :specs # :nodoc:
-
-  ##
-  # Creates a new LockSet from the given +source+
-
-  def initialize source
-    super()
-
-    @source = Gem::Source::Lock.new source
-    @specs  = []
-  end
-
-  ##
-  # Creates a new IndexSpecification in this set using the given +name+,
-  # +version+ and +platform+.
-  #
-  # The specification's set will be the current set, and the source will be
-  # the current set's source.
-
-  def add name, version, platform # :nodoc:
-    version = Gem::Version.new version
-
-    spec =
-      Gem::Resolver::LockSpecification.new self, name, version, @source,
-                                           platform
-
-    @specs << spec
-
-    spec
-  end
-
-  ##
-  # Returns an Array of IndexSpecification objects matching the
-  # DependencyRequest +req+.
-
-  def find_all req
-    @specs.select do |spec|
-      req.matches_spec? spec
-    end
-  end
-
-  ##
-  # Loads a Gem::Specification with the given +name+, +version+ and
-  # +platform+.  +source+ is ignored.
-
-  def load_spec name, version, platform, source # :nodoc:
-    dep = Gem::Dependency.new name, version
-
-    found = @specs.find do |spec|
-      dep.matches_spec? spec and spec.platform == platform
-    end
-
-    tuple = Gem::NameTuple.new found.name, found.version, found.platform
-
-    found.source.fetch_spec tuple
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[LockSet', ']' do
-      q.breakable
-      q.text 'source:'
-
-      q.breakable
-      q.pp @source
-
-      q.breakable
-      q.text 'specs:'
-
-      q.breakable
-      q.pp @specs.map { |spec| spec.full_name }
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/lock_specification.rb b/lib/rubygems/resolver/lock_specification.rb
deleted file mode 100644
index 4bc21b9..0000000
--- a/lib/rubygems/resolver/lock_specification.rb
+++ /dev/null
@@ -1,58 +0,0 @@
-##
-# The LockSpecification comes from a lockfile (Gem::RequestSet::Lockfile).
-#
-# A LockSpecification's dependency information is pre-filled from the
-# lockfile.
-
-class Gem::Resolver::LockSpecification < Gem::Resolver::Specification
-
-  def initialize set, name, version, source, platform
-    super()
-
-    @name     = name
-    @platform = platform
-    @set      = set
-    @source   = source
-    @version  = version
-
-    @dependencies = []
-    @spec         = nil
-  end
-
-  ##
-  # This is a null install as a locked specification is considered installed.
-  # +options+ are ignored.
-
-  def install options
-    destination = options[:install_dir] || Gem.dir
-
-    if File.exist? File.join(destination, 'specifications', spec.spec_name) then
-      yield nil
-      return
-    end
-
-    super
-  end
-
-  ##
-  # Adds +dependency+ from the lockfile to this specification
-
-  def add_dependency dependency # :nodoc:
-    @dependencies << dependency
-  end
-
-  ##
-  # A specification constructed from the lockfile is returned
-
-  def spec
-    @spec ||= Gem::Specification.new do |s|
-      s.name     = @name
-      s.version  = @version
-      s.platform = @platform
-
-      s.dependencies.concat @dependencies
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/requirement_list.rb b/lib/rubygems/resolver/requirement_list.rb
deleted file mode 100644
index a6bfaab..0000000
--- a/lib/rubygems/resolver/requirement_list.rb
+++ /dev/null
@@ -1,81 +0,0 @@
-##
-# The RequirementList is used to hold the requirements being considered
-# while resolving a set of gems.
-#
-# The RequirementList acts like a queue where the oldest items are removed
-# first.
-
-class Gem::Resolver::RequirementList
-
-  include Enumerable
-
-  ##
-  # Creates a new RequirementList.
-
-  def initialize
-    @exact = []
-    @list = []
-  end
-
-  def initialize_copy other # :nodoc:
-    @exact = @exact.dup
-    @list = @list.dup
-  end
-
-  ##
-  # Adds Resolver::DependencyRequest +req+ to this requirements list.
-
-  def add(req)
-    if req.requirement.exact?
-      @exact.push req
-    else
-      @list.push req
-    end
-    req
-  end
-
-  ##
-  # Enumerates requirements in the list
-
-  def each # :nodoc:
-    return enum_for __method__ unless block_given?
-
-    @exact.each do |requirement|
-      yield requirement
-    end
-
-    @list.each do |requirement|
-      yield requirement
-    end
-  end
-
-  ##
-  # How many elements are in the list
-
-  def size
-    @exact.size + @list.size
-  end
-
-  ##
-  # Is the list empty?
-
-  def empty?
-    @exact.empty? && @list.empty?
-  end
-
-  ##
-  # Remove the oldest DependencyRequest from the list.
-
-  def remove
-    return @exact.shift unless @exact.empty?
-    @list.shift
-  end
-
-  ##
-  # Returns the oldest five entries from the list.
-
-  def next5
-    x = @exact[0,5]
-    x + @list[0,5 - x.size]
-  end
-end
diff --git a/lib/rubygems/resolver/set.rb b/lib/rubygems/resolver/set.rb
deleted file mode 100644
index f053b65..0000000
--- a/lib/rubygems/resolver/set.rb
+++ /dev/null
@@ -1,44 +0,0 @@
-##
-# Resolver sets are used to look up specifications (and their
-# dependencies) used in resolution.  This set is abstract.
-
-class Gem::Resolver::Set
-
-  ##
-  # Set to true to disable network access for this set
-
-  attr_accessor :remote
-
-  def initialize # :nodoc:
-    @remote = true
-  end
-
-  ##
-  # The find_all method must be implemented.  It returns all Resolver
-  # Specification objects matching the given DependencyRequest +req+.
-
-  def find_all req
-    raise NotImplementedError
-  end
-
-  ##
-  # The #prefetch method may be overridden, but this is not necessary.  This
-  # default implementation does nothing, which is suitable for sets where
-  # looking up a specification is cheap (such as installed gems).
-  #
-  # When overridden, the #prefetch method should look up specifications
-  # matching +reqs+.
-
-  def prefetch reqs
-  end
-
-  ##
-  # When true, this set is allowed to access the network when looking up
-  # specifications or dependencies.
-
-  def remote? # :nodoc:
-    @remote
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/spec_specification.rb b/lib/rubygems/resolver/spec_specification.rb
deleted file mode 100644
index 0c411bd..0000000
--- a/lib/rubygems/resolver/spec_specification.rb
+++ /dev/null
@@ -1,58 +0,0 @@
-##
-# The Resolver::SpecSpecification contains common functionality for
-# Resolver specifications that are backed by a Gem::Specification.
-
-class Gem::Resolver::SpecSpecification < Gem::Resolver::Specification
-
-  attr_reader :spec # :nodoc:
-
-  ##
-  # A SpecSpecification is created for a +set+ for a Gem::Specification in
-  # +spec+.  The +source+ is either where the +spec+ came from, or should be
-  # loaded from.
-
-  def initialize set, spec, source = nil
-    @set    = set
-    @source = source
-    @spec   = spec
-  end
-
-  ##
-  # The dependencies of the gem for this specification
-
-  def dependencies
-    spec.dependencies
-  end
-
-  ##
-  # The name and version of the specification.
-  #
-  # Unlike Gem::Specification#full_name, the platform is not included.
-
-  def full_name
-    "#{spec.name}-#{spec.version}"
-  end
-
-  ##
-  # The name of the gem for this specification
-
-  def name
-    spec.name
-  end
-
-  ##
-  # The platform this gem works on.
-
-  def platform
-    spec.platform
-  end
-
-  ##
-  # The version of the gem for this specification.
-
-  def version
-    spec.version
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/specification.rb b/lib/rubygems/resolver/specification.rb
deleted file mode 100644
index d158225..0000000
--- a/lib/rubygems/resolver/specification.rb
+++ /dev/null
@@ -1,89 +0,0 @@
-##
-# A Resolver::Specification contains a subset of the information
-# contained in a Gem::Specification.  Only the information necessary for
-# dependency resolution in the resolver is included.
-
-class Gem::Resolver::Specification
-
-  ##
-  # The dependencies of the gem for this specification
-
-  attr_reader :dependencies
-
-  ##
-  # The name of the gem for this specification
-
-  attr_reader :name
-
-  ##
-  # The platform this gem works on.
-
-  attr_reader :platform
-
-  ##
-  # The set this specification came from.
-
-  attr_reader :set
-
-  ##
-  # The source for this specification
-
-  attr_reader :source
-
-  ##
-  # The version of the gem for this specification.
-
-  attr_reader :version
-
-  ##
-  # Sets default instance variables for the specification.
-
-  def initialize
-    @dependencies = nil
-    @name         = nil
-    @platform     = nil
-    @set          = nil
-    @source       = nil
-    @version      = nil
-  end
-
-  ##
-  # The name and version of the specification.
-  #
-  # Unlike Gem::Specification#full_name, the platform is not included.
-
-  def full_name
-    "#{@name}-#{@version}"
-  end
-
-  ##
-  # Installs this specification using the Gem::Installer +options+.  The
-  # install method yields a Gem::Installer instance, which indicates the
-  # gem will be installed, or +nil+, which indicates the gem is already
-  # installed.
-
-  def install options
-    require 'rubygems/installer'
-
-    destination = options[:install_dir] || Gem.dir
-
-    Gem.ensure_gem_subdirectories destination
-
-    gem = source.download spec, destination
-
-    installer = Gem::Installer.new gem, options
-
-    yield installer if block_given?
-
-    installer.install
-  end
-
-  ##
-  # Returns true if this specification is installable on this platform.
-
-  def installable_platform?
-    Gem::Platform.match spec.platform
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/stats.rb b/lib/rubygems/resolver/stats.rb
deleted file mode 100644
index c31e5be..0000000
--- a/lib/rubygems/resolver/stats.rb
+++ /dev/null
@@ -1,44 +0,0 @@
-class Gem::Resolver::Stats
-  def initialize
-    @max_depth = 0
-    @max_requirements = 0
-    @requirements = 0
-    @backtracking = 0
-    @iterations = 0
-  end
-
-  def record_depth(stack)
-    if stack.size > @max_depth
-      @max_depth = stack.size
-    end
-  end
-
-  def record_requirements(reqs)
-    if reqs.size > @max_requirements
-      @max_requirements = reqs.size
-    end
-  end
-
-  def requirement!
-    @requirements += 1
-  end
-
-  def backtracking!
-    @backtracking += 1
-  end
-
-  def iteration!
-    @iterations += 1
-  end
-
-  PATTERN = "%20s: %d\n"
-
-  def display
-    $stdout.puts "=== Resolver Statistics ==="
-    $stdout.printf PATTERN, "Max Depth", @max_depth
-    $stdout.printf PATTERN, "Total Requirements", @requirements
-    $stdout.printf PATTERN, "Max Requirements", @max_requirements
-    $stdout.printf PATTERN, "Backtracking #", @backtracking
-    $stdout.printf PATTERN, "Iteration #", @iterations
-  end
-end
diff --git a/lib/rubygems/resolver/vendor_set.rb b/lib/rubygems/resolver/vendor_set.rb
deleted file mode 100644
index 6e86707..0000000
--- a/lib/rubygems/resolver/vendor_set.rb
+++ /dev/null
@@ -1,85 +0,0 @@
-##
-# A VendorSet represents gems that have been unpacked into a specific
-# directory that contains a gemspec.
-#
-# This is used for gem dependency file support.
-#
-# Example:
-#
-#   set = Gem::Resolver::VendorSet.new
-#
-#   set.add_vendor_gem 'rake', 'vendor/rake'
-#
-# The directory vendor/rake must contain an unpacked rake gem along with a
-# rake.gemspec (watching the given name).
-
-class Gem::Resolver::VendorSet < Gem::Resolver::Set
-
-  ##
-  # The specifications for this set.
-
-  attr_reader :specs # :nodoc:
-
-  def initialize # :nodoc:
-    super()
-
-    @directories = {}
-    @specs       = {}
-  end
-
-  ##
-  # Adds a specification to the set with the given +name+ which has been
-  # unpacked into the given +directory+.
-
-  def add_vendor_gem name, directory # :nodoc:
-    gemspec = File.join directory, "#{name}.gemspec"
-
-    spec = Gem::Specification.load gemspec
-
-    raise Gem::GemNotFoundException,
-          "unable to find #{gemspec} for gem #{name}" unless spec
-
-    spec.full_gem_path = File.expand_path directory
-
-    @specs[spec.name]  = spec
-    @directories[spec] = directory
-  end
-
-  ##
-  # Returns an Array of VendorSpecification objects matching the
-  # DependencyRequest +req+.
-
-  def find_all req
-    @specs.values.select do |spec|
-      req.matches_spec? spec
-    end.map do |spec|
-      source = Gem::Source::Vendor.new @directories[spec]
-      Gem::Resolver::VendorSpecification.new self, spec, source
-    end
-  end
-
-  ##
-  # Loads a spec with the given +name+. +version+, +platform+ and +source+ are
-  # ignored.
-
-  def load_spec name, version, platform, source # :nodoc:
-    @specs.fetch name
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[VendorSet', ']' do
-      next if @directories.empty?
-      q.breakable
-
-      dirs = @directories.map do |spec, directory|
-        "#{spec.full_name}: #{directory}"
-      end
-
-      q.seplist dirs do |dir|
-        q.text dir
-      end
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/resolver/vendor_specification.rb b/lib/rubygems/resolver/vendor_specification.rb
deleted file mode 100644
index c6a8e58..0000000
--- a/lib/rubygems/resolver/vendor_specification.rb
+++ /dev/null
@@ -1,24 +0,0 @@
-##
-# A VendorSpecification represents a gem that has been unpacked into a project
-# and is being loaded through a gem dependencies file through the +path:+
-# option.
-
-class Gem::Resolver::VendorSpecification < Gem::Resolver::SpecSpecification
-
-  def == other # :nodoc:
-    self.class === other and
-      @set  == other.set and
-      @spec == other.spec and
-      @source == other.source
-  end
-
-  ##
-  # This is a null install as this gem was unpacked into a directory.
-  # +options+ are ignored.
-
-  def install options
-    yield nil
-  end
-
-end
-
diff --git a/lib/rubygems/security.rb b/lib/rubygems/security.rb
index 8c5fb7d..bfd6fd2 100644
--- a/lib/rubygems/security.rb
+++ b/lib/rubygems/security.rb
@@ -120,11 +120,11 @@ end
 # * HighSecurity - Here's the bugger that got us into this mess.
 #   The HighSecurity policy is identical to the MediumSecurity policy,
 #   except that it does not allow unsigned gems.  A malicious user
-#   doesn't have a whole lot of options here; they can't modify the
-#   package contents without invalidating the signature, and they can't
+#   doesn't have a whole lot of options here; he can't modify the
+#   package contents without invalidating the signature, and he can't
 #   modify or remove signature or the signing certificate chain, or
 #   RubyGems will simply refuse to install the package.  Oh well, maybe
-#   they'll have better luck causing problems for CPAN users instead :).
+#   he'll have better luck causing problems for CPAN users instead :).
 #
 # The reason RubyGems refused to install your shiny new signed gem was because
 # it was from an untrusted source.  Well, your code is infallible (naturally),
diff --git a/lib/rubygems/security/trust_dir.rb b/lib/rubygems/security/trust_dir.rb
index 76ef89a..dd51308 100644
--- a/lib/rubygems/security/trust_dir.rb
+++ b/lib/rubygems/security/trust_dir.rb
@@ -1,26 +1,10 @@
-##
-# The TrustDir manages the trusted certificates for gem signature
-# verification.
-
 class Gem::Security::TrustDir
 
-  ##
-  # Default permissions for the trust directory and its contents
-
   DEFAULT_PERMISSIONS = {
     :trust_dir    => 0700,
     :trusted_cert => 0600,
   }
 
-  ##
-  # The directory where trusted certificates will be stored.
-
-  attr_reader :dir
-
-  ##
-  # Creates a new TrustDir using +dir+ where the directory and file
-  # permissions will be checked according to +permissions+
-
   def initialize dir, permissions = DEFAULT_PERMISSIONS
     @dir = dir
     @permissions = permissions
@@ -28,6 +12,8 @@ class Gem::Security::TrustDir
     @digester = Gem::Security::DIGEST_ALGORITHM
   end
 
+  attr_reader :dir
+
   ##
   # Returns the path to the trusted +certificate+
 
diff --git a/lib/rubygems/source.rb b/lib/rubygems/source.rb
index 7f34e43..21756b0 100644
--- a/lib/rubygems/source.rb
+++ b/lib/rubygems/source.rb
@@ -1,30 +1,13 @@
 require 'uri'
 require 'fileutils'
 
-##
-# A Source knows how to list and fetch gems from a RubyGems marshal index.
-#
-# There are other Source subclasses for installed gems, local gems, the
-# bundler dependency API and so-forth.
-
 class Gem::Source
-
-  include Comparable
-
-  FILES = { # :nodoc:
+  FILES = {
     :released   => 'specs',
     :latest     => 'latest_specs',
     :prerelease => 'prerelease_specs',
   }
 
-  ##
-  # The URI this source will fetch gems from.
-
-  attr_reader :uri
-
-  ##
-  # Creates a new Source which will use the index located at +uri+.
-
   def initialize(uri)
     unless uri.kind_of? URI
       uri = URI.parse(uri.to_s)
@@ -34,25 +17,18 @@ class Gem::Source
     @api_uri = nil
   end
 
-  ##
-  # Use an SRV record on the host to look up the true endpoint for the index.
+  attr_reader :uri
 
-  def api_uri # :nodoc:
+  def api_uri
     require 'rubygems/remote_fetcher'
     @api_uri ||= Gem::RemoteFetcher.fetcher.api_endpoint uri
   end
 
-  ##
-  # Sources are ordered by installation preference.
-
   def <=>(other)
     case other
     when Gem::Source::Installed,
          Gem::Source::Local,
-         Gem::Source::Lock,
-         Gem::Source::SpecificFile,
-         Gem::Source::Git,
-         Gem::Source::Vendor then
+         Gem::Source::SpecificFile then
       -1
     when Gem::Source then
       if !@uri
@@ -68,29 +44,20 @@ class Gem::Source
     end
   end
 
-  def == other # :nodoc:
-    self.class === other and @uri == other.uri
-  end
-
-  alias_method :eql?, :== # :nodoc:
-
-  ##
-  # Returns a Set that can fetch specifications from this source.
-
-  def dependency_resolver_set # :nodoc:
-    bundler_api_uri = api_uri + './api/v1/dependencies'
+  include Comparable
 
-    begin
-      fetcher = Gem::RemoteFetcher.fetcher
-      fetcher.fetch_path bundler_api_uri, nil, true
-    rescue Gem::RemoteFetcher::FetchError
-      Gem::Resolver::IndexSet.new self
+  def ==(other)
+    case other
+    when self.class
+      @uri == other.uri
     else
-      Gem::Resolver::APISet.new bundler_api_uri
+      false
     end
   end
 
-  def hash # :nodoc:
+  alias_method :eql?, :==
+
+  def hash
     @uri.hash
   end
 
@@ -103,9 +70,6 @@ class Gem::Source
     File.join Gem.spec_cache_dir, "#{uri.host}%#{uri.port}", File.dirname(escaped_path)
   end
 
-  ##
-  # Returns true when it is possible and safe to update the cache directory.
-
   def update_cache?
     @update_cache ||=
       begin
@@ -115,15 +79,12 @@ class Gem::Source
       end
   end
 
-  ##
-  # Fetches a specification for the given +name_tuple+.
-
-  def fetch_spec name_tuple
+  def fetch_spec(name)
     fetcher = Gem::RemoteFetcher.fetcher
 
-    spec_file_name = name_tuple.spec_name
+    spec_file_name = name.spec_name
 
-    uri = api_uri + "#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}"
+    uri = @uri + "#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}"
 
     cache_dir = cache_dir uri
 
@@ -167,7 +128,7 @@ class Gem::Source
     file       = FILES[type]
     fetcher    = Gem::RemoteFetcher.fetcher
     file_name  = "#{file}.#{Gem.marshal_version}"
-    spec_path  = api_uri + "#{file_name}.gz"
+    spec_path  = @uri + "#{file_name}.gz"
     cache_dir  = cache_dir spec_path
     local_file = File.join(cache_dir, file_name)
     retried    = false
@@ -189,34 +150,20 @@ class Gem::Source
     end
   end
 
-  ##
-  # Downloads +spec+ and writes it to +dir+.  See also
-  # Gem::RemoteFetcher#download.
-
   def download(spec, dir=Dir.pwd)
     fetcher = Gem::RemoteFetcher.fetcher
-    fetcher.download spec, api_uri.to_s, dir
+    fetcher.download spec, @uri.to_s, dir
   end
 
   def pretty_print q # :nodoc:
     q.group 2, '[Remote:', ']' do
       q.breakable
       q.text @uri.to_s
-
-      if api = api_uri
-        q.breakable
-        q.text 'API URI: '
-        q.text api.to_s
-      end
     end
   end
 
 end
 
-require 'rubygems/source/git'
 require 'rubygems/source/installed'
 require 'rubygems/source/specific_file'
 require 'rubygems/source/local'
-require 'rubygems/source/lock'
-require 'rubygems/source/vendor'
-
diff --git a/lib/rubygems/source/git.rb b/lib/rubygems/source/git.rb
deleted file mode 100644
index 2e3fa03..0000000
--- a/lib/rubygems/source/git.rb
+++ /dev/null
@@ -1,232 +0,0 @@
-require 'digest'
-require 'rubygems/util'
-
-##
-# A git gem for use in a gem dependencies file.
-#
-# Example:
-#
-#   source =
-#     Gem::Source::Git.new 'rake', 'git@example:rake.git', 'rake-10.1.0', false
-#
-#   source.specs
-
-class Gem::Source::Git < Gem::Source
-
-  ##
-  # The name of the gem created by this git gem.
-
-  attr_reader :name
-
-  ##
-  # The commit reference used for checking out this git gem.
-
-  attr_reader :reference
-
-  ##
-  # When false the cache for this repository will not be updated.
-
-  attr_accessor :remote
-
-  ##
-  # The git repository this gem is sourced from.
-
-  attr_reader :repository
-
-  ##
-  # The directory for cache and git gem installation
-
-  attr_accessor :root_dir
-
-  ##
-  # Does this repository need submodules checked out too?
-
-  attr_reader :need_submodules
-
-  ##
-  # Creates a new git gem source for a gems from loaded from +repository+ at
-  # the given +reference+.  The +name+ is only used to track the repository
-  # back to a gem dependencies file, it has no real significance as a git
-  # repository may contain multiple gems.  If +submodules+ is true, submodules
-  # will be checked out when the gem is installed.
-
-  def initialize name, repository, reference, submodules = false
-    super(nil)
-
-    @name            = name
-    @repository      = repository
-    @reference       = reference
-    @need_submodules = submodules
-
-    @remote   = true
-    @root_dir = Gem.dir
-    @git      = ENV['git'] || 'git'
-  end
-
-  def <=> other
-    case other
-    when Gem::Source::Git then
-      0
-    when Gem::Source::Installed,
-         Gem::Source::Lock then
-      -1
-    when Gem::Source then
-      1
-    else
-      nil
-    end
-  end
-
-  def == other # :nodoc:
-    super and
-      @name            == other.name and
-      @repository      == other.repository and
-      @reference       == other.reference and
-      @need_submodules == other.need_submodules
-  end
-
-  ##
-  # Checks out the files for the repository into the install_dir.
-
-  def checkout # :nodoc:
-    cache
-
-    return false unless File.exist? repo_cache_dir
-
-    unless File.exist? install_dir then
-      system @git, 'clone', '--quiet', '--no-checkout',
-             repo_cache_dir, install_dir
-    end
-
-    Dir.chdir install_dir do
-      system @git, 'fetch', '--quiet', '--force', '--tags', install_dir
-
-      success = system @git, 'reset', '--quiet', '--hard', @reference
-
-      success &&=
-        Gem::Util.silent_system @git, 'submodule', 'update',
-               '--quiet', '--init', '--recursive' if @need_submodules
-
-      success
-    end
-  end
-
-  ##
-  # Creates a local cache repository for the git gem.
-
-  def cache # :nodoc:
-    return unless @remote
-
-    if File.exist? repo_cache_dir then
-      Dir.chdir repo_cache_dir do
-        system @git, 'fetch', '--quiet', '--force', '--tags',
-               @repository, 'refs/heads/*:refs/heads/*'
-      end
-    else
-      system @git, 'clone', '--quiet', '--bare', '--no-hardlinks',
-             @repository, repo_cache_dir
-    end
-  end
-
-  ##
-  # Directory where git gems get unpacked and so-forth.
-
-  def base_dir # :nodoc:
-    File.join @root_dir, 'bundler'
-  end
-
-  ##
-  # A short reference for use in git gem directories
-
-  def dir_shortref # :nodoc:
-    rev_parse[0..11]
-  end
-
-  ##
-  # Nothing to download for git gems
-
-  def download full_spec, path # :nodoc:
-  end
-
-  ##
-  # The directory where the git gem will be installed.
-
-  def install_dir # :nodoc:
-    return unless File.exist? repo_cache_dir
-
-    File.join base_dir, 'gems', "#{@name}-#{dir_shortref}"
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Git: ', ']' do
-      q.breakable
-      q.text @repository
-
-      q.breakable
-      q.text @reference
-    end
-  end
-
-  ##
-  # The directory where the git gem's repository will be cached.
-
-  def repo_cache_dir # :nodoc:
-    File.join @root_dir, 'cache', 'bundler', 'git', "#{@name}-#{uri_hash}"
-  end
-
-  ##
-  # Converts the git reference for the repository into a commit hash.
-
-  def rev_parse # :nodoc:
-    Dir.chdir repo_cache_dir do
-      Gem::Util.popen(@git, 'rev-parse', @reference).strip
-    end
-  end
-
-  ##
-  # Loads all gemspecs in the repository
-
-  def specs
-    checkout
-
-    return [] unless install_dir
-
-    Dir.chdir install_dir do
-      Dir['{,*,*/*}.gemspec'].map do |spec_file|
-        directory = File.dirname spec_file
-        file      = File.basename spec_file
-
-        Dir.chdir directory do
-          spec = Gem::Specification.load file
-          if spec then
-            spec.base_dir = base_dir
-
-            spec.extension_dir =
-              File.join base_dir, 'extensions', Gem::Platform.local.to_s,
-                Gem.extension_api_version, "#{name}-#{dir_shortref}"
-
-            spec.full_gem_path = File.dirname spec.loaded_from if spec
-          end
-          spec
-        end
-      end.compact
-    end
-  end
-
-  ##
-  # A hash for the git gem based on the git repository URI.
-
-  def uri_hash # :nodoc:
-    normalized =
-      if @repository =~ %r%^\w+://(\w+@)?% then
-        uri = URI(@repository).normalize.to_s.sub %r%/$%,''
-        uri.sub(/\A(\w+)/) { $1.downcase }
-      else
-        @repository
-      end
-
-    Digest::SHA1.hexdigest normalized
-  end
-
-end
-
diff --git a/lib/rubygems/source/installed.rb b/lib/rubygems/source/installed.rb
index 6d343c2..7709778 100644
--- a/lib/rubygems/source/installed.rb
+++ b/lib/rubygems/source/installed.rb
@@ -1,10 +1,6 @@
-##
-# Represents an installed gem.  This is used for dependency resolution.
-
 class Gem::Source::Installed < Gem::Source
 
-  def initialize # :nodoc:
-    @uri = nil
+  def initialize
   end
 
   ##
@@ -12,9 +8,6 @@ class Gem::Source::Installed < Gem::Source
 
   def <=> other
     case other
-    when Gem::Source::Lock,
-         Gem::Source::Vendor then
-      -1
     when Gem::Source::Installed then
       0
     when Gem::Source then
diff --git a/lib/rubygems/source/local.rb b/lib/rubygems/source/local.rb
index 8057921..08d1010 100644
--- a/lib/rubygems/source/local.rb
+++ b/lib/rubygems/source/local.rb
@@ -1,10 +1,5 @@
-##
-# The local source finds gems in the current directory for fulfilling
-# dependencies.
-
 class Gem::Source::Local < Gem::Source
-
-  def initialize # :nodoc:
+  def initialize
     @specs   = nil
     @api_uri = nil
     @uri     = nil
@@ -15,8 +10,7 @@ class Gem::Source::Local < Gem::Source
 
   def <=> other
     case other
-    when Gem::Source::Installed,
-         Gem::Source::Lock then
+    when Gem::Source::Installed then
       -1
     when Gem::Source::Local then
       0
@@ -32,7 +26,7 @@ class Gem::Source::Local < Gem::Source
     "#<%s specs: %p>" % [self.class, keys]
   end
 
-  def load_specs type # :nodoc:
+  def load_specs(type)
     names = []
 
     @specs = {}
@@ -74,8 +68,8 @@ class Gem::Source::Local < Gem::Source
     names
   end
 
-  def find_gem gem_name, version = Gem::Requirement.default, # :nodoc:
-               prerelease = false
+  def find_gem(gem_name, version=Gem::Requirement.default,
+               prerelease=false)
     load_specs :complete
 
     found = []
@@ -94,10 +88,10 @@ class Gem::Source::Local < Gem::Source
       end
     end
 
-    found.max_by { |s| s.version }
+    found.sort_by { |s| s.version }.last
   end
 
-  def fetch_spec name # :nodoc:
+  def fetch_spec(name)
     load_specs :complete
 
     if data = @specs[name]
@@ -107,7 +101,7 @@ class Gem::Source::Local < Gem::Source
     end
   end
 
-  def download spec, cache_dir = nil # :nodoc:
+  def download(spec, cache_dir=nil)
     load_specs :complete
 
     @specs.each do |name, data|
diff --git a/lib/rubygems/source/lock.rb b/lib/rubygems/source/lock.rb
deleted file mode 100644
index 2ba7702..0000000
--- a/lib/rubygems/source/lock.rb
+++ /dev/null
@@ -1,48 +0,0 @@
-##
-# A Lock source wraps an installed gem's source and sorts before other sources
-# during dependency resolution.  This allows RubyGems to prefer gems from
-# dependency lock files.
-
-class Gem::Source::Lock < Gem::Source
-
-  ##
-  # The wrapped Gem::Source
-
-  attr_reader :wrapped
-
-  ##
-  # Creates a new Lock source that wraps +source+ and moves it earlier in the
-  # sort list.
-
-  def initialize source
-    @wrapped = source
-  end
-
-  def <=> other # :nodoc:
-    case other
-    when Gem::Source::Lock then
-      @wrapped <=> other.wrapped
-    when Gem::Source then
-      1
-    else
-      nil
-    end
-  end
-
-  def == other # :nodoc:
-    0 == (self <=> other)
-  end
-
-  ##
-  # Delegates to the wrapped source's fetch_spec method.
-
-  def fetch_spec name_tuple
-    @wrapped.fetch_spec name_tuple
-  end
-
-  def uri # :nodoc:
-    @wrapped.uri
-  end
-
-end
-
diff --git a/lib/rubygems/source/specific_file.rb b/lib/rubygems/source/specific_file.rb
index a7b6c53..8d328b3 100644
--- a/lib/rubygems/source/specific_file.rb
+++ b/lib/rubygems/source/specific_file.rb
@@ -1,12 +1,4 @@
-##
-# A source representing a single .gem file.  This is used for installation of
-# local gems.
-
 class Gem::Source::SpecificFile < Gem::Source
-
-  ##
-  # Creates a new SpecificFile for the gem in +file+
-
   def initialize(file)
     @uri = nil
     @path = ::File.expand_path(file)
@@ -16,22 +8,19 @@ class Gem::Source::SpecificFile < Gem::Source
     @name = @spec.name_tuple
   end
 
-  ##
-  # The Gem::Specification extracted from this .gem.
-
   attr_reader :spec
 
-  def load_specs *a # :nodoc:
+  def load_specs(*a)
     [@name]
   end
 
-  def fetch_spec name # :nodoc:
+  def fetch_spec(name)
     return @spec if name == @name
     raise Gem::Exception, "Unable to find '#{name}'"
     @spec
   end
 
-  def download spec, dir = nil # :nodoc:
+  def download(spec, dir=nil)
     return @path if spec == @spec
     raise Gem::Exception, "Unable to download '#{spec.full_name}'"
   end
diff --git a/lib/rubygems/source/vendor.rb b/lib/rubygems/source/vendor.rb
deleted file mode 100644
index 2d93623..0000000
--- a/lib/rubygems/source/vendor.rb
+++ /dev/null
@@ -1,27 +0,0 @@
-##
-# This represents a vendored source that is similar to an installed gem.
-
-class Gem::Source::Vendor < Gem::Source::Installed
-
-  ##
-  # Creates a new Vendor source for a gem that was unpacked at +path+.
-
-  def initialize path
-    @uri = path
-  end
-
-  def <=> other
-    case other
-    when Gem::Source::Lock then
-      -1
-    when Gem::Source::Vendor then
-      0
-    when Gem::Source then
-      1
-    else
-      nil
-    end
-  end
-
-end
-
diff --git a/lib/rubygems/source_list.rb b/lib/rubygems/source_list.rb
index e01f11c..7bd8ef0 100644
--- a/lib/rubygems/source_list.rb
+++ b/lib/rubygems/source_list.rb
@@ -1,53 +1,28 @@
 require 'rubygems/source'
 
-##
-# The SourceList represents the sources rubygems has been configured to use.
-# A source may be created from an array of sources:
-#
-#   Gem::SourceList.from %w[https://rubygems.example https://internal.example]
-#
-# Or by adding them:
-#
-#   sources = Gem::SourceList.new
-#   sources.add 'https://rubygems.example'
-#
-# The most common way to get a SourceList is Gem.sources.
-
 class Gem::SourceList
-
-  include Enumerable
-
-  ##
-  # Creates a new SourceList
-
   def initialize
     @sources = []
   end
 
-  ##
-  # The sources in this list
-
   attr_reader :sources
 
-  ##
-  # Creates a new SourceList from an array of sources.
-
   def self.from(ary)
     list = new
 
-    list.replace ary
+    if ary
+      ary.each do |x|
+        list << x
+      end
+    end
 
     return list
   end
 
-  def initialize_copy(other) # :nodoc:
+  def initialize_copy(other)
     @sources = @sources.dup
   end
 
-  ##
-  # Appends +obj+ to the source list which may be a Gem::Source, URI or URI
-  # String.
-
   def <<(obj)
     src = case obj
           when URI
@@ -62,12 +37,8 @@ class Gem::SourceList
     src
   end
 
-  ##
-  # Replaces this SourceList with the sources in +other+  See #<< for
-  # acceptable items in +other+.
-
   def replace(other)
-    clear
+    @sources.clear
 
     other.each do |x|
       self << x
@@ -76,58 +47,28 @@ class Gem::SourceList
     self
   end
 
-  ##
-  # Removes all sources from the SourceList.
-
-  def clear
-    @sources.clear
-  end
-
-  ##
-  # Yields each source URI in the list.
-
   def each
     @sources.each { |s| yield s.uri.to_s }
   end
 
-  ##
-  # Yields each source in the list.
-
   def each_source(&b)
     @sources.each(&b)
   end
 
-  ##
-  # Returns true if there are no sources in this SourceList.
-
-  def empty?
-    @sources.empty?
-  end
-
-  def == other # :nodoc:
+  def ==(other)
     to_a == other
   end
 
-  ##
-  # Returns an Array of source URI Strings.
-
   def to_a
     @sources.map { |x| x.uri.to_s }
   end
 
   alias_method :to_ary, :to_a
 
-  ##
-  # Returns the first source in the list.
-
   def first
     @sources.first
   end
 
-  ##
-  # Returns true if this source list includes +other+ which may be a
-  # Gem::Source or a source URI.
-
   def include?(other)
     if other.kind_of? Gem::Source
       @sources.include? other
@@ -136,14 +77,11 @@ class Gem::SourceList
     end
   end
 
-  ##
-  # Deletes +source+ from the source list which may be a Gem::Source or a URI.
-
-  def delete source
-    if source.kind_of? Gem::Source
-      @sources.delete source
+  def delete(uri)
+    if uri.kind_of? Gem::Source
+      @sources.delete uri
     else
-      @sources.delete_if { |x| x.uri.to_s == source.to_s }
+      @sources.delete_if { |x| x.uri.to_s == uri.to_s }
     end
   end
 end
diff --git a/lib/rubygems/spec_fetcher.rb b/lib/rubygems/spec_fetcher.rb
index 12b8fb2..4bef933 100644
--- a/lib/rubygems/spec_fetcher.rb
+++ b/lib/rubygems/spec_fetcher.rb
@@ -18,11 +18,6 @@ class Gem::SpecFetcher
   attr_reader :latest_specs # :nodoc:
 
   ##
-  # Sources for this SpecFetcher
-
-  attr_reader :sources # :nodoc:
-
-  ##
   # Cache of all released specs
 
   attr_reader :specs # :nodoc:
@@ -34,10 +29,6 @@ class Gem::SpecFetcher
 
   @fetcher = nil
 
-  ##
-  # Default fetcher instance.  Use this instead of ::new to reduce object
-  # allocation.
-
   def self.fetcher
     @fetcher ||= new
   end
@@ -46,16 +37,7 @@ class Gem::SpecFetcher
     @fetcher = fetcher
   end
 
-  ##
-  # Creates a new SpecFetcher.  Ordinarily you want to use the default fetcher
-  # from Gem::SpecFetcher::fetcher which uses the Gem.sources.
-  #
-  # If you need to retrieve specifications from a different +source+, you can
-  # send it as an argument.
-
-  def initialize sources = nil
-    @sources = sources || Gem.sources
-
+  def initialize
     @update_cache =
       begin
         File.stat(Gem.user_home).uid == Process.uid
@@ -88,11 +70,7 @@ class Gem::SpecFetcher
     rejected_specs = {}
 
     if dependency.prerelease?
-      if dependency.specific?
-        type = :complete
-      else
-        type = :abs_latest
-      end
+      type = :complete
     elsif dependency.latest_version?
       type = :latest
     else
@@ -219,7 +197,7 @@ class Gem::SpecFetcher
     errors = []
     list = {}
 
-    @sources.each_source do |source|
+    Gem.sources.each_source do |source|
       begin
         names = case type
                 when :latest
@@ -232,12 +210,6 @@ class Gem::SpecFetcher
                     tuples_for(source, :released)
 
                   names.sort
-                when :abs_latest
-                  names =
-                    tuples_for(source, :prerelease, true) +
-                    tuples_for(source, :latest)
-
-                  names.sort
                 when :prerelease
                   tuples_for(source, :prerelease)
                 else
@@ -253,11 +225,7 @@ class Gem::SpecFetcher
     [list, errors]
   end
 
-  ##
-  # Retrieves NameTuples from +source+ of the given +type+ (:prerelease,
-  # etc.).  If +gracefully_ignore+ is true, errors are ignored.
-
-  def tuples_for(source, type, gracefully_ignore=false) # :nodoc:
+  def tuples_for(source, type, gracefully_ignore=false)
     cache = @caches[type]
 
     tuples =
diff --git a/lib/rubygems/specification.rb b/lib/rubygems/specification.rb
index f4e609a..ab3fa80 100644
--- a/lib/rubygems/specification.rb
+++ b/lib/rubygems/specification.rb
@@ -12,7 +12,6 @@ require 'rubygems/platform'
 require 'rubygems/deprecate'
 require 'rubygems/basic_specification'
 require 'rubygems/stub_specification'
-require 'rubygems/util/stringio'
 
 # :stopdoc:
 # date.rb can't be loaded for `make install` due to miniruby
@@ -27,7 +26,6 @@ class Date; end
 #   Gem::Specification.new do |s|
 #     s.name        = 'example'
 #     s.version     = '0.1.0'
-#     s.licenses    = ['MIT']
 #     s.summary     = "This is an example!"
 #     s.description = "Much longer explanation of the example!"
 #     s.authors     = ["Ruby Coder"]
@@ -73,13 +71,13 @@ class Gem::Specification < Gem::BasicSpecification
   #
   # NOTE RubyGems < 1.2 cannot load specification versions > 2.
 
-  CURRENT_SPECIFICATION_VERSION = 4 # :nodoc:
+  CURRENT_SPECIFICATION_VERSION = 4
 
   ##
   # An informal list of changes to the specification.  The highest-valued
   # key should be equal to the CURRENT_SPECIFICATION_VERSION.
 
-  SPECIFICATION_VERSION_HISTORY = { # :nodoc:
+  SPECIFICATION_VERSION_HISTORY = {
     -1 => ['(RubyGems versions up to and including 0.7 did not have versioned specifications)'],
     1  => [
       'Deprecated "test_suite_file" in favor of the new, but equivalent, "test_files"',
@@ -97,18 +95,12 @@ class Gem::Specification < Gem::BasicSpecification
     ]
   }
 
-  MARSHAL_FIELDS = { # :nodoc:
-    -1 => 16,
-     1 => 16,
-     2 => 16,
-     3 => 17,
-     4 => 18,
-  }
+  MARSHAL_FIELDS = { -1 => 16, 1 => 16, 2 => 16, 3 => 17, 4 => 18 }
 
   today = Time.now.utc
-  TODAY = Time.utc(today.year, today.month, today.day) # :nodoc:
+  TODAY = Time.utc(today.year, today.month, today.day)
 
-  LOAD_CACHE = {} # :nodoc:
+  LOAD_CACHE = {}
 
   private_constant :LOAD_CACHE if defined? private_constant
 
@@ -161,7 +153,7 @@ class Gem::Specification < Gem::BasicSpecification
     :version                   => nil,
   }
 
-  Dupable = { } # :nodoc:
+  Dupable = { }
 
   @@default_value.each do |k,v|
     case v
@@ -207,8 +199,6 @@ class Gem::Specification < Gem::BasicSpecification
   # Paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
   # activated.
   #
-  # See also #require_paths
-  #
   # If you have an extension you do not need to add <code>"ext"</code> to the
   # require path, the extension build process will copy the extension files
   # into "lib" for you.
@@ -220,7 +210,7 @@ class Gem::Specification < Gem::BasicSpecification
   #   # If all library files are in the root directory...
   #   spec.require_path = '.'
 
-  attr_writer :require_paths
+  attr_accessor :require_paths
 
   ##
   # The version of RubyGems used to create this gem.
@@ -241,28 +231,6 @@ class Gem::Specification < Gem::BasicSpecification
   attr_reader :summary
 
   ##
-  # Singular writer for #authors
-  #
-  # Usage:
-  #
-  #   spec.author = 'John Jones'
-
-  def author= o
-    self.authors = [o]
-  end
-
-  ##
-  # Sets the list of authors, ensuring it is an array.
-  #
-  # Usage:
-  #
-  #   spec.authors = ['John Jones', 'Mary Smith']
-
-  def authors= value
-    @authors = Array(value).flatten.grep(String)
-  end
-
-  ##
   # The platform this gem runs on.
   #
   # This is usually Gem::Platform::RUBY or Gem::Platform::CURRENT.
@@ -349,7 +317,7 @@ class Gem::Specification < Gem::BasicSpecification
               add_bindir(@executables),
               @extra_rdoc_files,
               @extensions,
-             ].flatten.uniq.compact.sort
+             ].flatten.uniq.compact
   end
 
   ######################################################################
@@ -465,6 +433,28 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
+  # Singular writer for #authors
+  #
+  # Usage:
+  #
+  #   spec.author = 'John Jones'
+
+  def author= o
+    self.authors = [o]
+  end
+
+  ##
+  # Sets the list of authors, ensuring it is an array.
+  #
+  # Usage:
+  #
+  #   spec.authors = ['John Jones', 'Mary Smith']
+
+  def authors= value
+    @authors = Array(value).flatten.grep(String)
+  end
+
+  ##
   # Executables included in the gem.
   #
   # For example, the rake gem has rake as an executable. You dont specify the
@@ -514,24 +504,6 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # The version of RubyGems that installed this gem.  Returns
-  # <code>Gem::Version.new(0)</code> for gems installed by versions earlier
-  # than RubyGems 2.2.0.
-
-  def installed_by_version # :nodoc:
-    @installed_by_version ||= Gem::Version.new(0)
-  end
-
-  ##
-  # Sets the version of RubyGems that installed this gem.  See also
-  # #installed_by_version.
-
-  def installed_by_version= version # :nodoc:
-    @installed_by_version = Gem::Version.new version
-  end
-
-  ##
-  # :category: Recommended gemspec attributes
   # The license for this gem.
   #
   # The license must be a short name, no more than 64 characters.
@@ -540,12 +512,7 @@ class Gem::Specification < Gem::BasicSpecification
   # text of the license should be inside of the gem when you build it.
   #
   # See http://opensource.org/licenses/alphabetical for a list of licenses and
-  # their abbreviations (or short names).  GitHub also provides a
-  # license picker at http://choosealicense.com/
-  #
-  #  According to copyright law, not having an OSI-approved open source license
-  #  means you have no rights to use the code for any purpose-- in other words,
-  #  "all rights reserved".
+  # their abbreviations (or short names).
   #
   # You can set multiple licenses with #licenses=
   #
@@ -557,7 +524,6 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # :category: Recommended gemspec attributes
   # The license(s) for the library.
   #
   # Each license must be a short name, no more than 64 characters.
@@ -705,7 +671,8 @@ class Gem::Specification < Gem::BasicSpecification
     LOAD_CACHE.clear
   end
 
-  def self.each_gemspec(dirs) # :nodoc:
+  # :nodoc:
+  def self.each_gemspec(dirs)
     dirs.each do |dir|
       Dir[File.join(dir, "*.gemspec")].each do |path|
         yield path.untaint
@@ -713,14 +680,16 @@ class Gem::Specification < Gem::BasicSpecification
     end
   end
 
-  def self.each_stub(dirs) # :nodoc:
+  # :nodoc:
+  def self.each_stub(dirs)
     each_gemspec(dirs) do |path|
       stub = Gem::StubSpecification.new(path)
       yield stub if stub.valid?
     end
   end
 
-  def self.each_spec(dirs) # :nodoc:
+  # :nodoc:
+  def self.each_spec(dirs)
     each_gemspec(dirs) do |path|
       spec = self.load path
       yield spec if spec
@@ -865,8 +834,12 @@ class Gem::Specification < Gem::BasicSpecification
   # this resets the list of known specs.
 
   def self.dirs= dirs
+    # TODO: find extra calls to dir=
+    # warn "NOTE: dirs= called from #{caller.first} for #{dirs.inspect}"
+
     self.reset
 
+    # ugh
     @@dirs = Array(dirs).map { |dir| File.join dir, "specifications" }
   end
 
@@ -1031,7 +1004,7 @@ class Gem::Specification < Gem::BasicSpecification
       spec = eval code, binding, file
 
       if Gem::Specification === spec
-        spec.loaded_from = File.expand_path file.to_s
+        spec.loaded_from = file.to_s
         LOAD_CACHE[file] = spec
         return spec
       end
@@ -1275,7 +1248,7 @@ class Gem::Specification < Gem::BasicSpecification
 
   ##
   # Activate all unambiguously resolved runtime dependencies of this
-  # spec. Add any ambiguous dependencies to the unresolved list to be
+  # spec. Add any ambigous dependencies to the unresolved list to be
   # resolved later, as needed.
 
   def activate_dependencies
@@ -1351,7 +1324,9 @@ class Gem::Specification < Gem::BasicSpecification
   def add_self_to_load_path
     return if default_gem?
 
-    paths = full_require_paths
+    paths = require_paths.map do |path|
+      File.join full_gem_path, path
+    end
 
     # gem directories must come after -I and ENV['RUBYLIB']
     insert_index = Gem.load_path_insert_index
@@ -1402,7 +1377,7 @@ class Gem::Specification < Gem::BasicSpecification
   # Returns the build_args used to install the gem
 
   def build_args
-    if File.exist? build_info_file
+    if File.exists? build_info_file
       File.readlines(build_info_file).map { |x| x.strip }
     else
       []
@@ -1410,37 +1385,6 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # Builds extensions for this platform if the gem has extensions listed and
-  # the gem.build_complete file is missing.
-
-  def build_extensions # :nodoc:
-    return if default_gem?
-    return if extensions.empty?
-    return if installed_by_version < Gem::Version.new('2.2.0.preview.2')
-    return if File.exist? gem_build_complete_path
-    return if !File.writable?(base_dir) &&
-              !File.exist?(File.join(base_dir, 'extensions'))
-
-    begin
-      # We need to require things in $LOAD_PATH without looking for the
-      # extension we are about to build.
-      unresolved_deps = Gem::Specification.unresolved_deps.dup
-      Gem::Specification.unresolved_deps.clear
-
-      require 'rubygems/config_file'
-      require 'rubygems/ext'
-      require 'rubygems/user_interaction'
-
-      Gem::DefaultUserInteraction.use_ui Gem::SilentUI.new do
-        builder = Gem::Ext::Builder.new self
-        builder.build_extensions
-      end
-    ensure
-      Gem::Specification.unresolved_deps.replace unresolved_deps
-    end
-  end
-
-  ##
   # Returns the full path to the build info directory
 
   def build_info_dir
@@ -1494,11 +1438,10 @@ class Gem::Specification < Gem::BasicSpecification
     @date ||= TODAY
   end
 
-  DateTimeFormat = # :nodoc:
-    /\A
-     (\d{4})-(\d{2})-(\d{2})
-     (\s+ \d{2}:\d{2}:\d{2}\.\d+ \s* (Z | [-+]\d\d:\d\d) )?
-     \Z/x
+  DateTimeFormat = /\A
+                     (\d{4})-(\d{2})-(\d{2})
+                     (\s+ \d{2}:\d{2}:\d{2}\.\d+ \s* (Z | [-+]\d\d:\d\d) )?
+                   \Z/x
 
   ##
   # The date this gem was created
@@ -1571,6 +1514,7 @@ class Gem::Specification < Gem::BasicSpecification
   #   [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]
 
   def dependent_gems
+    # REFACTOR: out = []; each; out; ? Really? No #collect love?
     out = []
     Gem::Specification.each do |spec|
       spec.dependencies.each do |dep|
@@ -1609,7 +1553,7 @@ class Gem::Specification < Gem::BasicSpecification
 
   ##
   # Returns the full path to this spec's documentation directory.  If +type+
-  # is given it will be appended to the end.  For example:
+  # is given it will be appended to the end.  For examlpe:
   #
   #   spec.doc_dir      # => "/path/to/gem_repo/doc/a-1"
   #
@@ -1730,7 +1674,8 @@ class Gem::Specification < Gem::BasicSpecification
     spec
   end
 
-  def find_full_gem_path # :nodoc:
+  # :nodoc:
+  def find_full_gem_path
     super || File.expand_path(File.join(gems_dir, original_name))
   end
   private :find_full_gem_path
@@ -1740,18 +1685,11 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # The path to the gem.build_complete file within the extension install
-  # directory.
-
-  def gem_build_complete_path # :nodoc:
-    File.join extension_dir, 'gem.build_complete'
-  end
-
-  ##
-  # Work around bundler removing my methods
+  # Returns the full path to this spec's gem directory.
+  # eg: /usr/local/lib/ruby/1.8/gems/mygem-1.0
 
-  def gem_dir # :nodoc:
-    super
+  def gem_dir
+    @gem_dir ||= File.expand_path File.join(gems_dir, full_name)
   end
 
   ##
@@ -1804,7 +1742,6 @@ class Gem::Specification < Gem::BasicSpecification
     @activated = false
     self.loaded_from = nil
     @original_platform = nil
-    @installed_by_version = nil
 
     @@nil_attributes.each do |key|
       instance_variable_set "@#{key}", nil
@@ -1860,7 +1797,7 @@ class Gem::Specification < Gem::BasicSpecification
 
   private :invalidate_memoized_attributes
 
-  def inspect # :nodoc:
+  def inspect
     if $DEBUG
       super
     else
@@ -1916,6 +1853,7 @@ class Gem::Specification < Gem::BasicSpecification
     @cache_dir     = nil
     @cache_file    = nil
     @doc_dir       = nil
+    @gem_dir       = nil
     @ri_dir        = nil
     @spec_dir      = nil
     @spec_file     = nil
@@ -2007,12 +1945,8 @@ class Gem::Specification < Gem::BasicSpecification
     q.group 2, 'Gem::Specification.new do |s|', 'end' do
       q.breakable
 
-      attributes = @@attributes - [:name, :version]
-      attributes.unshift :installed_by_version
-      attributes.unshift :version
-      attributes.unshift :name
-
-      attributes.each do |attr_name|
+      # REFACTOR: each_attr - use in to_yaml as well
+      @@attributes.each do |attr_name|
         current_value = self.send attr_name
         if current_value != default_value(attr_name) or
            self.class.required_attribute? attr_name then
@@ -2173,10 +2107,10 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # Used by Gem::Resolver to order Gem::Specification objects
+  # Used by Gem::DependencyResolver to order Gem::Specification objects
 
   def source # :nodoc:
-    Gem::Source::Installed.new
+    self
   end
 
   ##
@@ -2249,14 +2183,16 @@ class Gem::Specification < Gem::BasicSpecification
   # Returns a Ruby code representation of this specification, such that it can
   # be eval'ed and reconstruct the same specification later.  Attributes that
   # still have their default values are omitted.
+  #
+  # REFACTOR: This, plus stuff like #ruby_code and #pretty_print, should
+  # probably be extracted out into some sort of separate class. SRP, do you
+  # speak it!??!
 
   def to_ruby
     mark_version
     result = []
     result << "# -*- encoding: utf-8 -*-"
-    result << "#{Gem::StubSpecification::PREFIX}#{name} #{version} #{platform} #{@require_paths.join("\0")}"
-    result << "#{Gem::StubSpecification::PREFIX}#{extensions.join "\0"}" unless
-      extensions.empty?
+    result << "#{Gem::StubSpecification::PREFIX}#{name} #{version} #{platform} #{require_paths.join("\0")}"
     result << nil
     result << "Gem::Specification.new do |s|"
 
@@ -2271,13 +2207,11 @@ class Gem::Specification < Gem::BasicSpecification
     if metadata and !metadata.empty?
       result << "  s.metadata = #{ruby_code metadata} if s.respond_to? :metadata="
     end
-    result << "  s.require_paths = #{ruby_code @require_paths}"
 
     handled = [
       :dependencies,
       :name,
       :platform,
-      :require_paths,
       :required_rubygems_version,
       :specification_version,
       :version,
@@ -2295,11 +2229,6 @@ class Gem::Specification < Gem::BasicSpecification
       end
     end
 
-    if @installed_by_version then
-      result << nil
-      result << "  s.installed_by_version = \"#{Gem::VERSION}\" if s.respond_to? :installed_by_version"
-    end
-
     unless dependencies.empty? then
       result << nil
       result << "  if s.respond_to? :specification_version then"
@@ -2371,7 +2300,7 @@ class Gem::Specification < Gem::BasicSpecification
       builder << self
       ast = builder.tree
 
-      io = Gem::StringSink.new
+      io = StringIO.new
       io.set_encoding Encoding::UTF_8 if Object.const_defined? :Encoding
 
       Psych::Visitors::Emitter.new(io).accept(ast)
@@ -2409,7 +2338,6 @@ class Gem::Specification < Gem::BasicSpecification
   # checks..
 
   def validate packaging = true
-    @warnings = 0
     require 'rubygems/user_interaction'
     extend Gem::UserInteraction
     normalize
@@ -2440,7 +2368,7 @@ class Gem::Specification < Gem::BasicSpecification
             "invalid value for attribute name: \"#{name.inspect}\""
     end
 
-    if @require_paths.empty? then
+    if require_paths.empty? then
       raise Gem::InvalidSpecificationException,
             'specification must have at least one require_path'
     end
@@ -2458,11 +2386,6 @@ class Gem::Specification < Gem::BasicSpecification
             "[\"#{non_files.join "\", \""}\"] are not files"
     end
 
-    if files.include? file_name then
-      raise Gem::InvalidSpecificationException,
-            "#{full_name} contains itself (#{file_name}), check your files list"
-    end
-
     unless specification_version.is_a?(Fixnum)
       raise Gem::InvalidSpecificationException,
             'specification_version must be a Fixnum (did you mean version?)'
@@ -2490,6 +2413,7 @@ class Gem::Specification < Gem::BasicSpecification
       end
     end
 
+    # FIX: uhhhh single element array.each?
     [:authors].each do |field|
       val = self.send field
       raise Gem::InvalidSpecificationException, "#{field} may not be empty" if
@@ -2532,15 +2456,16 @@ class Gem::Specification < Gem::BasicSpecification
       end
     }
 
-    warning <<-warning if licenses.empty?
-licenses is empty, but is recommended.  Use a license abbreviation from:
-http://opensource.org/licenses/alphabetical
+    alert_warning <<-warning if licenses.empty?
+licenses is empty.  Use a license abbreviation from:
+  http://opensource.org/licenses/alphabetical
     warning
 
     validate_permissions
 
     # reject lazy developers:
 
+    # FIX: Doesn't this just evaluate to "FIXME" or "TODO"?
     lazy = '"FIxxxXME" or "TOxxxDO"'.gsub(/xxx/, '')
 
     unless authors.grep(/FI XME|TO DO/x).empty? then
@@ -2569,98 +2494,33 @@ http://opensource.org/licenses/alphabetical
 
     %w[author description email homepage summary].each do |attribute|
       value = self.send attribute
-      warning "no #{attribute} specified" if value.nil? or value.empty?
+      alert_warning "no #{attribute} specified" if value.nil? or value.empty?
     end
 
     if description == summary then
-      warning 'description and summary are identical'
+      alert_warning 'description and summary are identical'
     end
 
     # TODO: raise at some given date
-    warning "deprecated autorequire specified" if autorequire
+    alert_warning "deprecated autorequire specified" if autorequire
 
     executables.each do |executable|
       executable_path = File.join(bindir, executable)
       shebang = File.read(executable_path, 2) == '#!'
 
-      warning "#{executable_path} is missing #! line" unless shebang
-    end
-
-    validate_dependencies
-
-    true
-  ensure
-    if $! or @warnings > 0 then
-      alert_warning "See http://guides.rubygems.org/specification-reference/ for help"
+      alert_warning "#{executable_path} is missing #! line" unless shebang
     end
-  end
-
-  ##
-  # Checks that dependencies use requirements as we recommend.  Warnings are
-  # issued when dependencies are open-ended or overly strict for semantic
-  # versioning.
-
-  def validate_dependencies # :nodoc:
-    seen = {}
 
     dependencies.each do |dep|
-      if prev = seen[dep.name] then
-        raise Gem::InvalidSpecificationException, <<-MESSAGE
-duplicate dependency on #{dep}, (#{prev.requirement}) use:
-    add_runtime_dependency '#{dep.name}', '#{dep.requirement}', '#{prev.requirement}'
-        MESSAGE
-      end
-
-      seen[dep.name] = dep
-
       prerelease_dep = dep.requirements_list.any? do |req|
         Gem::Requirement.new(req).prerelease?
       end
 
-      warning "prerelease dependency on #{dep} is not recommended" if
+      alert_warning "prerelease dependency on #{dep} is not recommended" if
         prerelease_dep
-
-      overly_strict = dep.requirement.requirements.length == 1 &&
-        dep.requirement.requirements.any? do |op, version|
-          op == '~>' and
-            not version.prerelease? and
-            version.segments.length > 2
-        end
-
-      if overly_strict then
-        _, dep_version = dep.requirement.requirements.first
-
-        base = dep_version.segments.first 2
-
-        warning <<-WARNING
-pessimistic dependency on #{dep} may be overly strict
-  if #{dep.name} is semantically versioned, use:
-    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}', '>= #{dep_version}'
-        WARNING
-      end
-
-      open_ended = dep.requirement.requirements.all? do |op, version|
-        not version.prerelease? and (op == '>' or op == '>=')
-      end
-
-      if open_ended then
-        op, dep_version = dep.requirement.requirements.first
-
-        base = dep_version.segments.first 2
-
-        bugfix = if op == '>' then
-                   ", '> #{dep_version}'"
-                 elsif op == '>=' and base != dep_version.segments then
-                   ", '>= #{dep_version}'"
-                 end
-
-        warning <<-WARNING
-open-ended dependency on #{dep} is not recommended
-  if #{dep.name} is semantically versioned, use:
-    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}'#{bugfix}
-        WARNING
-      end
     end
+
+    true
   end
 
   ##
@@ -2671,13 +2531,13 @@ open-ended dependency on #{dep} is not recommended
 
     files.each do |file|
       next if File.stat(file).mode & 0444 == 0444
-      warning "#{file} is not world-readable"
+      alert_warning "#{file} is not world-readable"
     end
 
     executables.each do |name|
       exec = File.join @bindir, name
       next if File.stat(exec).executable?
-      warning "#{exec} is not executable"
+      alert_warning "#{exec} is not executable"
     end
   end
 
@@ -2694,10 +2554,7 @@ open-ended dependency on #{dep} is not recommended
     return @version
   end
 
-  def stubbed?
-    false
-  end
-
+  # FIX: have this handle the platform/new_platform/original_platform bullshit
   def yaml_initialize(tag, vals) # :nodoc:
     vals.each do |ivar, val|
       case ivar
@@ -2735,12 +2592,6 @@ open-ended dependency on #{dep} is not recommended
     @installed_by_version ||= nil
   end
 
-  def warning statement # :nodoc:
-    @warnings += 1
-
-    alert_warning statement
-  end
-
   extend Gem::Deprecate
 
   # TODO:
diff --git a/lib/rubygems/stub_specification.rb b/lib/rubygems/stub_specification.rb
index 221dc1d..08102b4 100644
--- a/lib/rubygems/stub_specification.rb
+++ b/lib/rubygems/stub_specification.rb
@@ -41,7 +41,6 @@ class Gem::StubSpecification < Gem::BasicSpecification
   def initialize(filename)
     self.loaded_from = filename
     @data            = nil
-    @extensions      = nil
     @spec            = nil
   end
 
@@ -53,31 +52,17 @@ class Gem::StubSpecification < Gem::BasicSpecification
     loaded && loaded.version == version
   end
 
-  def build_extensions # :nodoc:
-    return if default_gem?
-    return if extensions.empty?
-
-    to_spec.build_extensions
-  end
-
   ##
   # If the gemspec contains a stubline, returns a StubLine instance. Otherwise
   # returns the full Gem::Specification.
 
   def data
     unless @data
-      @extensions = []
-
       open loaded_from, OPEN_MODE do |file|
         begin
           file.readline # discard encoding line
           stubline = file.readline.chomp
-          if stubline.start_with?(PREFIX) then
-            @data = StubLine.new stubline
-
-            @extensions = $'.split "\0" if
-              /\A#{PREFIX}/ =~ file.readline.chomp
-          end
+          @data = StubLine.new(stubline) if stubline.start_with?(PREFIX)
         rescue EOFError
         end
       end
@@ -89,38 +74,6 @@ class Gem::StubSpecification < Gem::BasicSpecification
   private :data
 
   ##
-  # Extensions for this gem
-
-  def extensions
-    return @extensions if @extensions
-
-    data # load
-
-    @extensions
-  end
-
-  ##
-  # If a gem has a stub specification it doesn't need to bother with
-  # compatibility with original_name gems.  It was installed with the
-  # normalized name.
-
-  def find_full_gem_path # :nodoc:
-    path = File.expand_path File.join gems_dir, full_name
-    path.untaint
-    path
-  end
-
-  ##
-  # Full paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
-  # activated.
-
-  def full_require_paths
-    @require_paths ||= data.require_paths
-
-    super
-  end
-
-  ##
   # Name of the gem
 
   def name
@@ -139,8 +92,6 @@ class Gem::StubSpecification < Gem::BasicSpecification
 
   def require_paths
     @require_paths ||= data.require_paths
-
-    super
   end
 
   ##
@@ -165,12 +116,5 @@ class Gem::StubSpecification < Gem::BasicSpecification
     @version ||= data.version
   end
 
-  ##
-  # Is there a stub line present for this StubSpecification?
-
-  def stubbed?
-    data.is_a? StubLine
-  end
-
 end
 
diff --git a/lib/rubygems/syck_hack.rb b/lib/rubygems/syck_hack.rb
index 92179ab..5356aa0 100644
--- a/lib/rubygems/syck_hack.rb
+++ b/lib/rubygems/syck_hack.rb
@@ -10,9 +10,9 @@
 # class no matter if the full yaml library has loaded or not.
 #
 
-module YAML # :nodoc:
+module YAML
   # In newer 1.9.2, there is a Syck toplevel constant instead of it
-  # being underneath YAML. If so, reference it back under YAML as
+  # being underneith YAML. If so, reference it back under YAML as
   # well.
   if defined? ::Syck
     # for tests that change YAML::ENGINE
@@ -29,7 +29,7 @@ module YAML # :nodoc:
   # loaded, so lets define a stub for DefaultKey.
   elsif !defined? YAML::Syck
     module Syck
-      class DefaultKey # :nodoc:
+      class DefaultKey
       end
     end
   end
diff --git a/lib/rubygems/test_case.rb b/lib/rubygems/test_case.rb
index 328731d..d6c1a36 100644
--- a/lib/rubygems/test_case.rb
+++ b/lib/rubygems/test_case.rb
@@ -24,19 +24,17 @@ unless Gem::Dependency.new('rdoc', '>= 3.10').matching_specs.empty?
   gem 'json'
 end
 
-require 'minitest/autorun'
-
 require 'rubygems/deprecate'
-
+require 'minitest/autorun'
 require 'fileutils'
-require 'pathname'
-require 'pp'
-require 'rubygems/package'
-require 'shellwords'
 require 'tmpdir'
 require 'uri'
+require 'rubygems/package'
+require 'rubygems/test_utilities'
+require 'pp'
 require 'zlib'
-
+require 'pathname'
+require 'shellwords'
 Gem.load_yaml
 
 require 'rubygems/mock_gem_ui'
@@ -86,12 +84,6 @@ end
 
 class Gem::TestCase < MiniTest::Unit::TestCase
 
-  attr_accessor :fetcher # :nodoc:
-
-  attr_accessor :gem_repo # :nodoc:
-
-  attr_accessor :uri # :nodoc:
-
   def assert_activate expected, *specs
     specs.each do |spec|
       case spec
@@ -115,23 +107,6 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     assert File.exist?(path), msg
   end
 
-  ##
-  # Sets the ENABLE_SHARED entry in RbConfig::CONFIG to +value+ and restores
-  # the original value when the block ends
-
-  def enable_shared value
-    enable_shared = RbConfig::CONFIG['ENABLE_SHARED']
-    RbConfig::CONFIG['ENABLE_SHARED'] = value
-
-    yield
-  ensure
-    if enable_shared then
-      RbConfig::CONFIG['enable_shared'] = enable_shared
-    else
-      RbConfig::CONFIG.delete 'enable_shared'
-    end
-  end
-
   # TODO: move to minitest
   def refute_path_exists path, msg = nil
     msg = message(msg) { "Expected path '#{path}' to not exist" }
@@ -222,8 +197,7 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     @orig_gem_path = ENV['GEM_PATH']
 
     @current_dir = Dir.pwd
-    @fetcher     = nil
-    @ui          = Gem::MockGemUi.new
+    @ui = Gem::MockGemUi.new
 
     tmpdir = File.expand_path Dir.tmpdir
     tmpdir.untaint
@@ -257,8 +231,6 @@ class Gem::TestCase < MiniTest::Unit::TestCase
                    ruby
                  end
 
-    @git = ENV['GIT'] || 'git'
-
     Gem.ensure_gem_subdirectories @gemhome
 
     @orig_LOAD_PATH = $LOAD_PATH.dup
@@ -269,8 +241,6 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     @orig_ENV_HOME = ENV['HOME']
     ENV['HOME'] = @userhome
     Gem.instance_variable_set :@user_home, nil
-    Gem.send :remove_instance_variable, :@ruby_version if
-      Gem.instance_variables.include? :@ruby_version
 
     FileUtils.mkdir_p @gemhome
     FileUtils.mkdir_p @userhome
@@ -311,10 +281,10 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
     Gem.searcher = nil
     Gem::SpecFetcher.fetcher = nil
-    @orig_BASERUBY = RbConfig::CONFIG['BASERUBY']
-    RbConfig::CONFIG['BASERUBY'] = RbConfig::CONFIG['ruby_install_name']
+    @orig_BASERUBY = Gem::ConfigMap[:BASERUBY]
+    Gem::ConfigMap[:BASERUBY] = Gem::ConfigMap[:ruby_install_name]
 
-    @orig_arch = RbConfig::CONFIG['arch']
+    @orig_arch = Gem::ConfigMap[:arch]
 
     if win_platform?
       util_set_arch 'i386-mswin32'
@@ -332,12 +302,8 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   def teardown
     $LOAD_PATH.replace @orig_LOAD_PATH if @orig_LOAD_PATH
 
-    if @orig_BASERUBY
-      RbConfig::CONFIG['BASERUBY'] = @orig_BASERUBY
-    else
-      RbConfig::CONFIG.delete('BASERUBY')
-    end
-    RbConfig::CONFIG['arch'] = @orig_arch
+    Gem::ConfigMap[:BASERUBY] = @orig_BASERUBY
+    Gem::ConfigMap[:arch] = @orig_arch
 
     if defined? Gem::RemoteFetcher then
       Gem::RemoteFetcher.fetcher = nil
@@ -403,64 +369,6 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   ##
-  # A git_gem is used with a gem dependencies file.  The gem created here
-  # has no files, just a gem specification for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def git_gem name = 'a', version = 1
-    have_git?
-
-    directory = File.join 'git', name
-    directory = File.expand_path directory
-
-    git_spec = Gem::Specification.new name, version do |specification|
-      yield specification if block_given?
-    end
-
-    FileUtils.mkdir_p directory
-
-    gemspec = "#{name}.gemspec"
-
-    open File.join(directory, gemspec), 'w' do |io|
-      io.write git_spec.to_ruby
-    end
-
-    head = nil
-
-    Dir.chdir directory do
-      unless File.exist? '.git' then
-        system @git, 'init', '--quiet'
-        system @git, 'config', 'user.name',  'RubyGems Tests'
-        system @git, 'config', 'user.email', 'rubygems@example'
-      end
-
-      system @git, 'add', gemspec
-      system @git, 'commit', '-a', '-m', 'a non-empty commit message', '--quiet'
-      head = Gem::Util.popen('git', 'rev-parse', 'master').strip
-    end
-
-    return name, git_spec.version, directory, head
-  end
-
-  ##
-  # Skips this test unless you have a git executable
-
-  def have_git?
-    return if in_path? @git
-
-    skip 'cannot find git executable, use GIT environment variable to set'
-  end
-
-  def in_path? executable # :nodoc:
-    return true if %r%\A([A-Z]:|/)% =~ executable and File.exist? executable
-
-    ENV['PATH'].split(File::PATH_SEPARATOR).any? do |directory|
-      File.exist? File.join directory, executable
-    end
-  end
-
-  ##
   # Builds and installs the Gem::Specification +spec+
 
   def install_gem spec, options = {}
@@ -468,7 +376,7 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
     gem = File.join @tempdir, "gems", "#{spec.full_name}.gem"
 
-    unless File.exist? gem then
+    unless File.exists? gem
       use_ui Gem::MockGemUi.new do
         Dir.chdir @tempdir do
           Gem::Package.build spec
@@ -593,11 +501,28 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     return spec
   end
 
-  ##
-  # TODO:  remove in RubyGems 3.0
+  def quick_spec name, version = '2'
+    # TODO: deprecate
+    require 'rubygems/specification'
+
+    spec = Gem::Specification.new do |s|
+      s.platform    = Gem::Platform::RUBY
+      s.name        = name
+      s.version     = version
+      s.author      = 'A User'
+      s.email       = 'example@example.com'
+      s.homepage    = 'http://example.com'
+      s.summary     = "this is a summary"
+      s.description = "This is a test description"
+
+      yield(s) if block_given?
+    end
+
+    spec.loaded_from = spec.spec_file
+
+    Gem::Specification.add_spec spec
 
-  def quick_spec name, version = '2' # :nodoc:
-    util_spec name, version
+    return spec
   end
 
   ##
@@ -634,9 +559,7 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
   def util_clear_gems
     FileUtils.rm_rf File.join(@gemhome, "gems") # TODO: use Gem::Dirs
-    FileUtils.mkdir File.join(@gemhome, "gems")
     FileUtils.rm_rf File.join(@gemhome, "specifications")
-    FileUtils.mkdir File.join(@gemhome, "specifications")
     Gem::Specification.reset
   end
 
@@ -687,11 +610,10 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   ##
-  # new_spec is deprecated as it is never used.
-  #
-  # TODO:  remove in RubyGems 3.0
+  # Create a new spec (or gem if passed an array of files) and set it
+  # up properly. Use this instead of util_spec and util_gem.
 
-  def new_spec name, version, deps = nil, *files # :nodoc:
+  def new_spec name, version, deps = nil, *files
     require 'rubygems/specification'
 
     spec = Gem::Specification.new do |s|
@@ -732,8 +654,7 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   def new_default_spec(name, version, deps = nil, *files)
-    spec = util_spec name, version, deps
-
+    spec = new_spec(name, version, deps)
     spec.loaded_from = File.join(@default_spec_dir, spec.spec_name)
     spec.files = files
 
@@ -751,38 +672,24 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   ##
-  # Creates a spec with +name+, +version+.  +deps+ can specify the dependency
-  # or a +block+ can be given for full customization of the specification.
-
-  def util_spec name, version = 2, deps = nil # :yields: specification
-    raise "deps or block, not both" if deps and block_given?
+  # Creates a spec with +name+, +version+ and +deps+.
 
-    spec = Gem::Specification.new do |s|
-      s.platform    = Gem::Platform::RUBY
-      s.name        = name
-      s.version     = version
-      s.author      = 'A User'
-      s.email       = 'example@example.com'
-      s.homepage    = 'http://example.com'
-      s.summary     = "this is a summary"
-      s.description = "This is a test description"
-
-      yield s if block_given?
-    end
+  def util_spec(name, version, deps = nil, &block)
+    # TODO: deprecate
+    raise "deps or block, not both" if deps and block
 
     if deps then
-      # Since Hash#each is unordered in 1.8, sort the keys and iterate that
-      # way so the tests are deterministic on all implementations.
-      deps.keys.sort.each do |n|
-        spec.add_dependency n, (deps[n] || '>= 0')
+      block = proc do |s|
+        # Since Hash#each is unordered in 1.8, sort
+        # the keys and iterate that way so the tests are
+        # deteriminstic on all implementations.
+        deps.keys.sort.each do |n|
+          s.add_dependency n, (deps[n] || '>= 0')
+        end
       end
     end
 
-    spec.loaded_from = spec.spec_file
-
-    Gem::Specification.add_spec spec
-
-    return spec
+    quick_spec(name, version, &block)
   end
 
   ##
@@ -919,7 +826,7 @@ Also, a list:
   # Set the platform to +arch+
 
   def util_set_arch(arch)
-    RbConfig::CONFIG['arch'] = arch
+    Gem::ConfigMap[:arch] = arch
     platform = Gem::Platform.new arch
 
     Gem.instance_variable_set :@platforms, nil
@@ -991,35 +898,14 @@ Also, a list:
       spec_fetcher.prerelease_specs[@uri] << spec.name_tuple
     end
 
-    # HACK for test_download_to_cache
-    unless Gem::RemoteFetcher === @fetcher then
-      v = Gem.marshal_version
-
-      specs = all.map { |spec| spec.name_tuple }
-      s_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic specs
-
-      latest_specs = Gem::Specification.latest_specs.map do |spec|
-        spec.name_tuple
-      end
-
-      l_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic latest_specs
-
-      prerelease_specs = prerelease.map { |spec| spec.name_tuple }
-      p_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic prerelease_specs
+    v = Gem.marshal_version
 
-      @fetcher.data["#{@gem_repo}specs.#{v}.gz"]            = s_zip
-      @fetcher.data["#{@gem_repo}latest_specs.#{v}.gz"]     = l_zip
-      @fetcher.data["#{@gem_repo}prerelease_specs.#{v}.gz"] = p_zip
-
-      v = Gem.marshal_version
-
-      Gem::Specification.each do |spec|
-        path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
-        data = Marshal.dump spec
-        data_deflate = Zlib::Deflate.deflate data
-        @fetcher.data[path] = data_deflate
-      end
-    end
+    Gem::Specification.each do |spec|
+      path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
+      data = Marshal.dump spec
+      data_deflate = Zlib::Deflate.deflate data
+      @fetcher.data[path] = data_deflate
+    end unless Gem::RemoteFetcher === @fetcher # HACK for test_download_to_cache
 
     nil # force errors
   end
@@ -1170,23 +1056,21 @@ Also, a list:
   end
 
   ##
-  # Constructs a Gem::Resolver::DependencyRequest from a
+  # Constructs a Gem::DependencyResolver::DependencyRequest from a
   # Gem::Dependency +dep+, a +from_name+ and +from_version+ requesting the
   # dependency and a +parent+ DependencyRequest
 
   def dependency_request dep, from_name, from_version, parent = nil
     remote = Gem::Source.new @uri
 
-    unless parent then
-      parent_dep = dep from_name, from_version
-      parent = Gem::Resolver::DependencyRequest.new parent_dep, nil
-    end
+    parent ||= Gem::DependencyResolver::DependencyRequest.new \
+      dep, nil
 
-    spec = Gem::Resolver::IndexSpecification.new \
+    spec = Gem::DependencyResolver::IndexSpecification.new \
       nil, from_name, from_version, remote, Gem::Platform::RUBY
-    activation = Gem::Resolver::ActivationRequest.new spec, parent
+    activation = Gem::DependencyResolver::ActivationRequest.new spec, parent
 
-    Gem::Resolver::DependencyRequest.new dep, activation
+    Gem::DependencyResolver::DependencyRequest.new dep, activation
   end
 
   ##
@@ -1205,107 +1089,31 @@ Also, a list:
   end
 
   ##
-  # Creates a SpecFetcher pre-filled with the gems or specs defined in the
-  # block.
-  #
-  # Yields a +fetcher+ object that responds to +spec+ and +gem+.  +spec+ adds
-  # a specification to the SpecFetcher while +gem+ adds both a specification
-  # and the gem data to the RemoteFetcher so the built gem can be downloaded.
-  #
-  # If only the a-3 gem is supposed to be downloaded you can save setup
-  # time by creating only specs for the other versions:
-  #
-  #   spec_fetcher do |fetcher|
-  #     fetcher.spec 'a', 1
-  #     fetcher.spec 'a', 2, 'b' => 3 # dependency on b = 3
-  #     fetcher.gem 'a', 3 do |spec|
-  #       # spec is a Gem::Specification
-  #       # ...
-  #     end
-  #   end
-
-  def spec_fetcher repository = @gem_repo
-    Gem::TestCase::SpecFetcherSetup.declare self, repository do |spec_fetcher_setup|
-      yield spec_fetcher_setup if block_given?
-    end
-  end
-
-  ##
   # Construct a new Gem::Version.
 
   def v string
     Gem::Version.create string
   end
 
-  ##
-  # A vendor_gem is used with a gem dependencies file.  The gem created here
-  # has no files, just a gem specification for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def vendor_gem name = 'a', version = 1
-    directory = File.join 'vendor', name
-
-    vendor_spec = Gem::Specification.new name, version do |specification|
-      yield specification if block_given?
-    end
-
-    FileUtils.mkdir_p directory
-
-    open File.join(directory, "#{name}.gemspec"), 'w' do |io|
-      io.write vendor_spec.to_ruby
-    end
-
-    return name, vendor_spec.version, directory
-  end
-
-  ##
-  # The StaticSet is a static set of gem specifications used for testing only.
-  # It is available by requiring Gem::TestCase.
-
   class StaticSet
-
-    ##
-    # A StaticSet ignores remote because it has a fixed set of gems.
-
-    attr_accessor :remote
-
-    ##
-    # Creates a new StaticSet for the given +specs+
-
     def initialize(specs)
       @specs = specs
-
-      @remote = true
     end
 
-    ##
-    # Adds +spec+ to this set.
-
     def add spec
       @specs << spec
     end
 
-    ##
-    # Finds +dep+ in this set.
-
     def find_spec(dep)
       @specs.reverse_each do |s|
         return s if dep.matches_spec? s
       end
     end
 
-    ##
-    # Finds all gems matching +dep+ in this set.
-
     def find_all(dep)
       @specs.find_all { |s| dep.matches_spec? s }
     end
 
-    ##
-    # Loads a Gem::Specification from this set which has the given +name+,
-    # version +ver+, +platform+.  The +source+ is ignored.
-
     def load_spec name, ver, platform, source
       dep = Gem::Dependency.new name, ver
       spec = find_spec dep
@@ -1315,7 +1123,7 @@ Also, a list:
       end
     end
 
-    def prefetch reqs # :nodoc:
+    def prefetch(reqs)
     end
   end
 
@@ -1388,6 +1196,3 @@ Also, a list:
   end if defined?(OpenSSL::SSL)
 
 end
-
-require 'rubygems/test_utilities'
-
diff --git a/lib/rubygems/test_utilities.rb b/lib/rubygems/test_utilities.rb
index 3deb71f..eed42f5 100644
--- a/lib/rubygems/test_utilities.rb
+++ b/lib/rubygems/test_utilities.rb
@@ -101,24 +101,6 @@ class Gem::FakeFetcher
     response
   end
 
-  def pretty_print q # :nodoc:
-    q.group 2, '[FakeFetcher', ']' do
-      q.breakable
-      q.text 'URIs:'
-
-      q.breakable
-      q.pp @data.keys
-
-      unless @api_endpoints.empty? then
-        q.breakable
-        q.text 'API endpoints:'
-
-        q.breakable
-        q.pp @api_endpoints.keys
-      end
-    end
-  end
-
   def fetch_size(path)
     path = path.to_s
     @paths << path
@@ -178,179 +160,6 @@ end
 # :startdoc:
 
 ##
-# The SpecFetcherSetup allows easy setup of a remote source in RubyGems tests:
-#
-#   spec_fetcher do |f|
-#     f.gem  'a', 1
-#     f.spec 'a', 2
-#     f.gem  'b', 1' 'a' => '~> 1.0'
-#     f.clear
-#   end
-#
-# The above declaration creates two gems, a-1 and b-1, with a dependency from
-# b to a.  The declaration creates an additional spec a-2, but no gem for it
-# (so it cannot be installed).
-#
-# After the gems are created they are removed from Gem.dir.
-
-class Gem::TestCase::SpecFetcherSetup
-
-  ##
-  # Executes a SpecFetcher setup block.  Yields an instance then creates the
-  # gems and specifications defined in the instance.
-
-  def self.declare test, repository
-    setup = new test, repository
-
-    yield setup
-
-    setup.execute
-  end
-
-  def initialize test, repository # :nodoc:
-    @test       = test
-    @repository = repository
-
-    @gems       = {}
-    @installed  = []
-    @operations = []
-  end
-
-  ##
-  # Removes any created gems or specifications from Gem.dir (the default
-  # install location).
-
-  def clear
-    @operations << [:clear]
-  end
-
-  ##
-  # Returns a Hash of created Specification full names and the corresponding
-  # Specification.
-
-  def created_specs
-    created = {}
-
-    @gems.keys.each do |spec|
-      created[spec.full_name] = spec
-    end
-
-    created
-  end
-
-  ##
-  # Creates any defined gems or specifications
-
-  def execute # :nodoc:
-    execute_operations
-
-    setup_fetcher
-
-    created_specs
-  end
-
-  def execute_operations # :nodoc:
-    @operations.each do |operation, *arguments|
-      case operation
-      when :clear then
-        @test.util_clear_gems
-        @installed.clear
-      when :gem then
-        spec, gem = @test.util_gem(*arguments, &arguments.pop)
-
-        write_spec spec
-
-        @gems[spec] = gem
-        @installed << spec
-      when :spec then
-        spec = @test.util_spec(*arguments, &arguments.pop)
-
-        write_spec spec
-
-        @gems[spec] = nil
-        @installed << spec
-      end
-    end
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The created gem can be
-  # downloaded and installed.
-  #
-  # The specification will be yielded before gem creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def gem name, version, dependencies = nil, &block
-    @operations << [:gem, name, version, dependencies, block]
-  end
-
-  ##
-  # Creates a legacy platform spec with the name 'pl' and version 1
-
-  def legacy_platform
-    spec 'pl', 1 do |s|
-      s.platform = Gem::Platform.new 'i386-linux'
-      s.instance_variable_set :@original_platform, 'i386-linux'
-    end
-  end
-
-  def setup_fetcher # :nodoc:
-    require 'zlib'
-    require 'socket'
-    require 'rubygems/remote_fetcher'
-
-    unless @test.fetcher then
-      @test.fetcher = Gem::FakeFetcher.new
-      Gem::RemoteFetcher.fetcher = @test.fetcher
-    end
-
-    Gem::Specification.reset
-
-    begin
-      gem_repo, @test.gem_repo = @test.gem_repo, @repository
-      @test.uri = URI @repository
-
-      @test.util_setup_spec_fetcher(*@gems.keys)
-    ensure
-      @test.gem_repo = gem_repo
-      @test.uri = URI gem_repo
-    end
-
-    # This works around util_setup_spec_fetcher adding all created gems to the
-    # installed set.
-    Gem::Specification.reset
-    Gem::Specification.add_specs(*@installed)
-
-    @gems.each do |spec, gem|
-      next unless gem
-
-      @test.fetcher.data["#{@repository}gems/#{spec.file_name}"] =
-        Gem.read_binary(gem)
-
-      FileUtils.cp gem, spec.cache_file
-    end
-  end
-
-  ##
-  # Creates a spec with +name+, +version+ and +deps+.  The created gem can be
-  # downloaded and installed.
-  #
-  # The specification will be yielded before creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def spec name, version, dependencies = nil, &block
-    @operations << [:spec, name, version, dependencies, block]
-  end
-
-  def write_spec spec # :nodoc:
-    open spec.spec_file, 'w' do |io|
-      io.write spec.to_ruby_for_cache
-    end
-  end
-
-end
-
-##
 # A StringIO duck-typed class that uses Tempfile instead of String as the
 # backing store.
 #
@@ -359,10 +168,6 @@ end
 # This class was added to flush out problems in Rubinius' IO implementation.
 
 class TempIO < Tempfile
-
-  ##
-  # Creates a new TempIO that will be initialized to contain +string+.
-
   def initialize(string = '')
     super "TempIO"
     binmode
@@ -370,9 +175,6 @@ class TempIO < Tempfile
     rewind
   end
 
-  ##
-  # The content of the TempIO as a String.
-
   def string
     flush
     Gem.read_binary path
diff --git a/lib/rubygems/uninstaller.rb b/lib/rubygems/uninstaller.rb
index fa83833..143ab6d 100644
--- a/lib/rubygems/uninstaller.rb
+++ b/lib/rubygems/uninstaller.rb
@@ -237,7 +237,7 @@ class Gem::Uninstaller
     unless path_ok?(@gem_home, spec) or
            (@user_install and path_ok?(Gem.user_dir, spec)) then
       e = Gem::GemNotInHomeException.new \
-            "Gem '#{spec.full_name}' is not installed in directory #{@gem_home}"
+            "Gem is not installed in directory #{@gem_home}"
       e.spec = spec
 
       raise e
@@ -247,10 +247,13 @@ class Gem::Uninstaller
       File.writable?(spec.base_dir)
 
     FileUtils.rm_rf spec.full_gem_path
-    FileUtils.rm_rf spec.extension_dir
 
-    old_platform_name = spec.original_name
-    gemspec           = spec.spec_file
+    # TODO: should this be moved to spec?... I vote eww (also exists in docmgr)
+    old_platform_name = [spec.name,
+                         spec.version,
+                         spec.original_platform].join '-'
+
+    gemspec = spec.spec_file
 
     unless File.exist? gemspec then
       gemspec = File.join(File.dirname(gemspec), "#{old_platform_name}.gemspec")
@@ -281,30 +284,18 @@ class Gem::Uninstaller
     full_path == spec.full_gem_path || original_path == spec.full_gem_path
   end
 
-  ##
-  # Returns true if it is OK to remove +spec+ or this is a forced
-  # uninstallation.
-
-  def dependencies_ok? spec # :nodoc:
+  def dependencies_ok?(spec)
     return true if @force_ignore
 
     deplist = Gem::DependencyList.from_specs
     deplist.ok_to_remove?(spec.full_name, @check_dev)
   end
 
-  ##
-  # Should the uninstallation abort if a dependency will go unsatisfied?
-  #
-  # See ::new.
-
-  def abort_on_dependent? # :nodoc:
+  def abort_on_dependent?
     @abort_on_dependent
   end
 
-  ##
-  # Asks if it is OK to remove +spec+.  Returns true if it is OK.
-
-  def ask_if_ok spec # :nodoc:
+  def ask_if_ok(spec)
     msg = ['']
     msg << 'You have requested to uninstall the gem:'
     msg << "\t#{spec.full_name}"
@@ -325,10 +316,7 @@ class Gem::Uninstaller
     return ask_yes_no(msg.join("\n"), false)
   end
 
-  ##
-  # Returns the formatted version of the executable +filename+
-
-  def formatted_program_filename filename # :nodoc:
+  def formatted_program_filename(filename)
     # TODO perhaps the installer should leave a small manifest
     # of what it did for us to find rather than trying to recreate
     # it again.
diff --git a/lib/rubygems/uri_formatter.rb b/lib/rubygems/uri_formatter.rb
index 68aacc6..935d9b5 100644
--- a/lib/rubygems/uri_formatter.rb
+++ b/lib/rubygems/uri_formatter.rb
@@ -1,30 +1,13 @@
 require 'cgi'
 require 'uri'
 
-##
-# The UriFormatter handles URIs from user-input and escaping.
-#
-#   uf = Gem::UriFormatter.new 'example.com'
-#
-#   p uf.normalize #=> 'http://example.com'
-
 class Gem::UriFormatter
-
-  ##
-  # The URI to be formatted.
-
   attr_reader :uri
 
-  ##
-  # Creates a new URI formatter for +uri+.
-
   def initialize uri
     @uri = uri
   end
 
-  ##
-  # Escapes the #uri for use as a CGI parameter
-
   def escape
     return unless @uri
     CGI.escape @uri
@@ -37,9 +20,6 @@ class Gem::UriFormatter
     (@uri =~ /^(https?|ftp|file):/i) ? @uri : "http://#{@uri}"
   end
 
-  ##
-  # Unescapes the #uri which came from a CGI parameter
-
   def unescape
     return unless @uri
     CGI.unescape @uri
diff --git a/lib/rubygems/user_interaction.rb b/lib/rubygems/user_interaction.rb
index f5e460f..0974476 100644
--- a/lib/rubygems/user_interaction.rb
+++ b/lib/rubygems/user_interaction.rb
@@ -4,11 +4,6 @@
 # See LICENSE.txt for permissions.
 #++
 
-begin
-  require 'io/console'
-rescue LoadError
-end
-
 ##
 # Module that defines the default UserInteraction.  Any class including this
 # module will have access to the +ui+ method that returns the default UI.
@@ -71,13 +66,9 @@ module Gem::DefaultUserInteraction
 end
 
 ##
-# UserInteraction allows RubyGems to interact with the user through standard
-# methods that can be replaced with more-specific UI methods for different
-# displays.
-#
-# Since UserInteraction dispatches to a concrete UI class you may need to
-# reference other classes for specific behavior such as Gem::ConsoleUI or
-# Gem::SilentUI.
+# Make the default UI accessible without the "ui." prefix.  Classes
+# including this module may use the interaction methods on the default UI
+# directly.  Classes may also reference the ui and ui= methods.
 #
 # Example:
 #
@@ -93,69 +84,40 @@ module Gem::UserInteraction
 
   include Gem::DefaultUserInteraction
 
-  ##
-  # Displays an alert +statement+.  Asks a +question+ if given.
-
-  def alert statement, question = nil
-    ui.alert statement, question
+  def alert(*args)
+    ui.alert(*args)
   end
 
-  ##
-  # Displays an error +statement+ to the error output location.  Asks a
-  # +question+ if given.
-
-  def alert_error statement, question = nil
-    ui.alert_error statement, question
+  def alert_error(*args)
+    ui.alert_error(*args)
   end
 
-  ##
-  # Displays a warning +statement+ to the warning output location.  Asks a
-  # +question+ if given.
-
-  def alert_warning statement, question = nil
-    ui.alert_warning statement, question
+  def alert_warning(*args)
+    ui.alert_warning(*args)
   end
 
-  ##
-  # Asks a +question+ and returns the answer.
-
-  def ask question
-    ui.ask question
+  def ask(*args)
+    ui.ask(*args)
   end
 
-  ##
-  # Asks for a password with a +prompt+
-
-  def ask_for_password prompt
-    ui.ask_for_password prompt
+  def ask_for_password(*args)
+    ui.ask_for_password(*args)
   end
 
-  ##
-  # Asks a yes or no +question+.  Returns true for yes, false for no.
-
-  def ask_yes_no question, default = nil
-    ui.ask_yes_no question, default
+  def ask_yes_no(*args)
+    ui.ask_yes_no(*args)
   end
 
-  ##
-  # Asks the user to answer +question+ with an answer from the given +list+.
-
-  def choose_from_list question, list
-    ui.choose_from_list question, list
+  def choose_from_list(*args)
+    ui.choose_from_list(*args)
   end
 
-  ##
-  # Displays the given +statement+ on the standard output (or equivalent).
-
-  def say statement = ''
-    ui.say statement
+  def say(*args)
+    ui.say(*args)
   end
 
-  ##
-  # Terminates the RubyGems process with the given +exit_code+
-
-  def terminate_interaction exit_code = 0
-    ui.terminate_interaction exit_code
+  def terminate_interaction(*args)
+    ui.terminate_interaction(*args)
   end
 end
 
@@ -164,26 +126,7 @@ end
 
 class Gem::StreamUI
 
-  ##
-  # The input stream
-
-  attr_reader :ins
-
-  ##
-  # The output stream
-
-  attr_reader :outs
-
-  ##
-  # The error stream
-
-  attr_reader :errs
-
-  ##
-  # Creates a new StreamUI wrapping +in_stream+ for user input, +out_stream+
-  # for standard output, +err_stream+ for error output.  If +usetty+ is true
-  # then special operations (like asking for passwords) will use the TTY
-  # commands to disable character echo.
+  attr_reader :ins, :outs, :errs
 
   def initialize(in_stream, out_stream, err_stream=STDERR, usetty=true)
     @ins = in_stream
@@ -192,9 +135,6 @@ class Gem::StreamUI
     @usetty = usetty
   end
 
-  ##
-  # Returns true if TTY methods should be used on this StreamUI.
-
   def tty?
     if RUBY_VERSION < '1.9.3' and RUBY_PLATFORM =~ /mingw|mswin/ then
       @usetty
@@ -288,27 +228,41 @@ class Gem::StreamUI
     result
   end
 
-  ##
-  # Ask for a password. Does not echo response to terminal.
+  if RUBY_VERSION > '1.9.2' then
+    ##
+    # Ask for a password. Does not echo response to terminal.
 
-  def ask_for_password(question)
-    return nil if not tty?
+    def ask_for_password(question)
+      return nil if not tty?
 
-    @outs.print(question, "  ")
-    @outs.flush
+      require 'io/console'
 
-    password = _gets_noecho
-    @outs.puts
-    password.chomp! if password
-    password
-  end
+      @outs.print(question + "  ")
+      @outs.flush
 
-  if IO.method_defined?(:noecho) then
-    def _gets_noecho
-      @ins.noecho {@ins.gets}
+      password = @ins.noecho {@ins.gets}
+      password.chomp! if password
+      password
     end
-  elsif Gem.win_platform?
-    def _gets_noecho
+  else
+    ##
+    # Ask for a password. Does not echo response to terminal.
+
+    def ask_for_password(question)
+      return nil if not tty?
+
+      @outs.print(question + "  ")
+      @outs.flush
+
+      Gem.win_platform? ? ask_for_password_on_windows : ask_for_password_on_unix
+    end
+
+    ##
+    # Asks for a password that works on windows. Ripped from the Heroku gem.
+
+    def ask_for_password_on_windows
+      return nil if not tty?
+
       require "Win32API"
       char = nil
       password = ''
@@ -321,16 +275,22 @@ class Gem::StreamUI
           password << char.chr
         end
       end
+
+      puts
       password
     end
-  else
-    def _gets_noecho
+
+    ##
+    # Asks for a password that works on unix
+
+    def ask_for_password_on_unix
+      return nil if not tty?
+
       system "stty -echo"
-      begin
-        @ins.gets
-      ensure
-        system "stty echo"
-      end
+      password = @ins.gets
+      password.chomp! if password
+      system "stty echo"
+      password
     end
   end
 
@@ -350,7 +310,8 @@ class Gem::StreamUI
   end
 
   ##
-  # Display a warning on stderr.  Will ask +question+ if it is not nil.
+  # Display a warning in a location expected to get error messages.  Will
+  # ask +question+ if it is not nil.
 
   def alert_warning(statement, question=nil)
     @errs.puts "WARNING:  #{statement}"
@@ -403,29 +364,14 @@ class Gem::StreamUI
   # An absolutely silent progress reporter.
 
   class SilentProgressReporter
-
-    ##
-    # The count of items is never updated for the silent progress reporter.
-
     attr_reader :count
 
-    ##
-    # Creates a silent progress reporter that ignores all input arguments.
-
     def initialize(out_stream, size, initial_message, terminal_message = nil)
     end
 
-    ##
-    # Does not print +message+ when updated as this object has taken a vow of
-    # silence.
-
     def updated(message)
     end
 
-    ##
-    # Does not print anything when complete as this object has taken a vow of
-    # silence.
-
     def done
     end
   end
@@ -437,16 +383,8 @@ class Gem::StreamUI
 
     include Gem::DefaultUserInteraction
 
-    ##
-    # The number of progress items counted so far.
-
     attr_reader :count
 
-    ##
-    # Creates a new progress reporter that will write to +out_stream+ for
-    # +size+ items.  Shows the given +initial_message+ when progress starts
-    # and the +terminal_message+ when it is complete.
-
     def initialize(out_stream, size, initial_message,
                    terminal_message = "complete")
       @out = out_stream
@@ -482,16 +420,8 @@ class Gem::StreamUI
 
     include Gem::DefaultUserInteraction
 
-    ##
-    # The number of progress items counted so far.
-
     attr_reader :count
 
-    ##
-    # Creates a new progress reporter that will write to +out_stream+ for
-    # +size+ items.  Shows the given +initial_message+ when progress starts
-    # and the +terminal_message+ when it is complete.
-
     def initialize(out_stream, size, initial_message,
                    terminal_message = 'complete')
       @out = out_stream
@@ -538,30 +468,15 @@ class Gem::StreamUI
   # An absolutely silent download reporter.
 
   class SilentDownloadReporter
-
-    ##
-    # The silent download reporter ignores all arguments
-
     def initialize(out_stream, *args)
     end
 
-    ##
-    # The silent download reporter does not display +filename+ or care about
-    # +filesize+ because it is silent.
-
     def fetch(filename, filesize)
     end
 
-    ##
-    # Nothing can update the silent download reporter.
-
     def update(current)
     end
 
-    ##
-    # The silent download reporter won't tell you when the download is done.
-    # Because it is silent.
-
     def done
     end
   end
@@ -570,35 +485,13 @@ class Gem::StreamUI
   # A progress reporter that prints out messages about the current progress.
 
   class VerboseDownloadReporter
-
-    ##
-    # The current file name being displayed
-
-    attr_reader :file_name
-
-    ##
-    # The total bytes in the file
-
-    attr_reader :total_bytes
-
-    ##
-    # The current progress (0 to 100)
-
-    attr_reader :progress
-
-    ##
-    # Creates a new verbose download reporter that will display on
-    # +out_stream+.  The other arguments are ignored.
+    attr_reader :file_name, :total_bytes, :progress
 
     def initialize(out_stream, *args)
       @out = out_stream
       @progress = 0
     end
 
-    ##
-    # Tells the download reporter that the +file_name+ is being fetched and
-    # contains +total_bytes+.
-
     def fetch(file_name, total_bytes)
       @file_name = file_name
       @total_bytes = total_bytes.to_i
@@ -607,9 +500,6 @@ class Gem::StreamUI
       update_display(false)
     end
 
-    ##
-    # Updates the verbose download reporter for the given number of +bytes+.
-
     def update(bytes)
       new_progress = if @units == 'B' then
                        bytes
@@ -623,9 +513,6 @@ class Gem::StreamUI
       update_display
     end
 
-    ##
-    # Indicates the download is complete.
-
     def done
       @progress = 100 if @units == '%'
       update_display(true, true)
@@ -633,7 +520,7 @@ class Gem::StreamUI
 
     private
 
-    def update_display(show_progress = true, new_line = false) # :nodoc:
+    def update_display(show_progress = true, new_line = false)
       return unless @out.tty?
 
       if show_progress then
@@ -651,11 +538,6 @@ end
 # STDOUT, and STDERR.
 
 class Gem::ConsoleUI < Gem::StreamUI
-
-  ##
-  # The Console UI has no arguments as it defaults to reading input from
-  # stdin, output to stdout and warnings or errors to stderr.
-
   def initialize
     super STDIN, STDOUT, STDERR, true
   end
@@ -665,10 +547,6 @@ end
 # SilentUI is a UI choice that is absolutely silent.
 
 class Gem::SilentUI < Gem::StreamUI
-
-  ##
-  # The SilentUI has no arguments as it does not use any stream.
-
   def initialize
     reader, writer = nil, nil
 
@@ -683,11 +561,11 @@ class Gem::SilentUI < Gem::StreamUI
     super reader, writer, writer, false
   end
 
-  def download_reporter(*args) # :nodoc:
+  def download_reporter(*args)
     SilentDownloadReporter.new(@outs, *args)
   end
 
-  def progress_reporter(*args) # :nodoc:
+  def progress_reporter(*args)
     SilentProgressReporter.new(@outs, *args)
   end
 end
diff --git a/lib/rubygems/util.rb b/lib/rubygems/util.rb
deleted file mode 100644
index 408942d..0000000
--- a/lib/rubygems/util.rb
+++ /dev/null
@@ -1,121 +0,0 @@
-##
-# This module contains various utility methods as module methods.
-
-module Gem::Util
-
-  @silent_mutex = nil
-
-  ##
-  # Zlib::GzipReader wrapper that unzips +data+.
-
-  def self.gunzip(data)
-    require 'zlib'
-    require 'rubygems/util/stringio'
-    data = Gem::StringSource.new data
-
-    unzipped = Zlib::GzipReader.new(data).read
-    unzipped.force_encoding Encoding::BINARY if Object.const_defined? :Encoding
-    unzipped
-  end
-
-  ##
-  # Zlib::GzipWriter wrapper that zips +data+.
-
-  def self.gzip(data)
-    require 'zlib'
-    require 'rubygems/util/stringio'
-    zipped = Gem::StringSink.new
-    zipped.set_encoding Encoding::BINARY if Object.const_defined? :Encoding
-
-    Zlib::GzipWriter.wrap zipped do |io| io.write data end
-
-    zipped.string
-  end
-
-  ##
-  # A Zlib::Inflate#inflate wrapper
-
-  def self.inflate(data)
-    require 'zlib'
-    Zlib::Inflate.inflate data
-  end
-
-  ##
-  # This calls IO.popen where it accepts an array for a +command+ (Ruby 1.9+)
-  # and implements an IO.popen-like behavior where it does not accept an array
-  # for a command.
-
-  def self.popen *command
-    IO.popen command, &:read
-  rescue TypeError # ruby 1.8 only supports string command
-    r, w = IO.pipe
-
-    pid = fork do
-      STDIN.close
-      STDOUT.reopen w
-
-      exec(*command)
-    end
-
-    w.close
-
-    begin
-      return r.read
-    ensure
-      Process.wait pid
-    end
-  end
-
-  ##
-  # Invokes system, but silences all output.
-
-  def self.silent_system *command
-    require 'thread'
-
-    @silent_mutex ||= Mutex.new
-
-    null_device = Gem.win_platform? ? 'NUL' : '/dev/null'
-
-    @silent_mutex.synchronize do
-      begin
-        stdout = STDOUT.dup
-        stderr = STDERR.dup
-
-        STDOUT.reopen null_device, 'w'
-        STDERR.reopen null_device, 'w'
-
-        return system(*command)
-      ensure
-        STDOUT.reopen stdout
-        STDERR.reopen stderr
-      end
-    end
-  end
-
-  ##
-  # Enumerates the parents of +directory+.
-
-  def self.traverse_parents directory
-    return enum_for __method__, directory unless block_given?
-
-    here = File.expand_path directory
-    start = here
-
-    Dir.chdir start
-
-    begin
-      loop do
-        yield here
-
-        Dir.chdir '..'
-
-        return if Dir.pwd == here # toplevel
-
-        here = Dir.pwd
-      end
-    ensure
-      Dir.chdir start
-    end
-  end
-
-end
diff --git a/lib/rubygems/util/list.rb b/lib/rubygems/util/list.rb
index 9bc11fe..9f540ad 100644
--- a/lib/rubygems/util/list.rb
+++ b/lib/rubygems/util/list.rb
@@ -36,10 +36,6 @@ module Gem
       List.new value, self
     end
 
-    def pretty_print q # :nodoc:
-      q.pp to_a
-    end
-
     def self.prepend(list, value)
       return List.new(value) unless list
       List.new value, list
diff --git a/lib/rubygems/util/stringio.rb b/lib/rubygems/util/stringio.rb
deleted file mode 100644
index 2ea6961..0000000
--- a/lib/rubygems/util/stringio.rb
+++ /dev/null
@@ -1,34 +0,0 @@
-class Gem::StringSink
-  def initialize
-    @string = ""
-  end
-
-  attr_reader :string
-
-  def write(s)
-    @string += s
-    s.size
-  end
-
-  def set_encoding(enc)
-    @string.force_encoding enc
-  end
-end
-
-class Gem::StringSource
-  def initialize(str)
-    @string = str.dup
-  end
-
-  def read(count=nil)
-    if count
-      @string.slice!(0,count)
-    else
-      s = @string
-      @string = ""
-      s
-    end
-  end
-
-  alias_method :readpartial, :read
-end
diff --git a/lib/rubygems/validator.rb b/lib/rubygems/validator.rb
index 6992af1..e5183d4 100644
--- a/lib/rubygems/validator.rb
+++ b/lib/rubygems/validator.rb
@@ -14,7 +14,7 @@ class Gem::Validator
 
   include Gem::UserInteraction
 
-  def initialize # :nodoc:
+  def initialize
     require 'find'
   end
 
@@ -57,11 +57,8 @@ class Gem::Validator
 
   public
 
-  ##
-  # Describes a problem with a file in a gem.
-
   ErrorData = Struct.new :path, :problem do
-    def <=> other # :nodoc:
+    def <=> other
       return nil unless self.class === other
 
       [path, problem] <=> [other.path, other.problem]
@@ -86,7 +83,6 @@ class Gem::Validator
 
     Gem::Specification.each do |spec|
       next unless gems.include? spec.name unless gems.empty?
-      next if spec.default_gem?
 
       gem_name      = spec.file_name
       gem_path      = spec.cache_file
diff --git a/lib/rubygems/version.rb b/lib/rubygems/version.rb
index 2066332..10b0503 100644
--- a/lib/rubygems/version.rb
+++ b/lib/rubygems/version.rb
@@ -22,11 +22,6 @@
 # 3. 1.0.a.2
 # 4. 0.9
 #
-# If you want to specify a version restriction that includes both prereleases
-# and regular releases of the 1.x series this is the best way:
-#
-#   s.add_dependency 'example', '>= 1.0.0.a', '< 2.0.0'
-#
 # == How Software Changes
 #
 # Users expect to be able to specify a version constraint that gives them
@@ -86,8 +81,8 @@
 #
 # * Any "public" release of a gem should have a different version.  Normally
 #   that means incrementing the build number.  This means a developer can
-#   generate builds all day long, but as soon as they make a public release,
-#   the version must be updated.
+#   generate builds all day long for himself, but as soon as he/she makes a
+#   public release, the version must be updated.
 #
 # === Examples
 #
@@ -104,25 +99,26 @@
 # Version 1.1.1:: Fixed a bug in the linked list implementation.
 # Version 1.1.2:: Fixed a bug introduced in the last fix.
 #
-# Client A needs a stack with basic push/pop capability.  They write to the
-# original interface (no <tt>top</tt>), so their version constraint looks like:
+# Client A needs a stack with basic push/pop capability.  He writes to the
+# original interface (no <tt>top</tt>), so his version constraint looks
+# like:
 #
 #   gem 'stack', '~> 0.0'
 #
 # Essentially, any version is OK with Client A.  An incompatible change to
-# the library will cause them grief, but they are willing to take the chance
-# (we call Client A optimistic).
+# the library will cause him grief, but he is willing to take the chance (we
+# call Client A optimistic).
 #
-# Client B is just like Client A except for two things: (1) They use the
-# <tt>depth</tt> method and (2) they are worried about future
-# incompatibilities, so they write their version constraint like this:
+# Client B is just like Client A except for two things: (1) He uses the
+# <tt>depth</tt> method and (2) he is worried about future
+# incompatibilities, so he writes his version constraint like this:
 #
 #   gem 'stack', '~> 0.1'
 #
 # The <tt>depth</tt> method was introduced in version 0.1.0, so that version
 # or anything later is fine, as long as the version stays below version 1.0
 # where incompatibilities are introduced.  We call Client B pessimistic
-# because they are worried about incompatible future changes (it is OK to be
+# because he is worried about incompatible future changes (it is OK to be
 # pessimistic!).
 #
 # == Preventing Version Catastrophe:
@@ -149,6 +145,8 @@ class Gem::Version
 
   include Comparable
 
+  # FIX: These are only used once, in .correct?. Do they deserve to be
+  # constants?
   VERSION_PATTERN = '[0-9]+(?>\.[0-9a-zA-Z]+)*(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?' # :nodoc:
   ANCHORED_VERSION_PATTERN = /\A\s*(#{VERSION_PATTERN})?\s*\z/ # :nodoc:
 
@@ -176,6 +174,8 @@ class Gem::Version
   #   ver2 = Version.create(ver1)       # -> (ver1)
   #   ver3 = Version.create(nil)        # -> nil
 
+  # REFACTOR: There's no real reason this should be separate from #initialize.
+
   def self.create input
     if self === input then # check yourself before you wreck yourself
       input
@@ -188,9 +188,7 @@ class Gem::Version
 
   @@all = {}
 
-  def self.new version # :nodoc:
-    return super unless Gem::VERSION == self.class
-
+  def self.new version
     @@all[version] ||= super
   end
 
@@ -257,17 +255,17 @@ class Gem::Version
     initialize array[0]
   end
 
-  def yaml_initialize(tag, map) # :nodoc:
+  def yaml_initialize(tag, map)
     @version = map['version']
     @segments = nil
     @hash = nil
   end
 
-  def to_yaml_properties # :nodoc:
+  def to_yaml_properties
     ["@version"]
   end
 
-  def encode_with coder # :nodoc:
+  def encode_with coder
     coder.add 'version', @version
   end
 
